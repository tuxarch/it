#
#	WELCOME TO SQUID 3.1.9
#	----------------------------
#
#	Это дефолтный конфигурационный файл Squid-а. Возможно Вам захочется
#	заглянуть на домашнюю страницу Squid-а (http://www.squid-cache.org/)
#	за FAQ-ами и другой документацией.
#
#	Дефолтный конфиг-файл Squid-а показывает, что происходит по умолчанию для
#	различных опций. Если Вам нет нужды менять значение по умолчанию, то Вы
#	не должны раскомментировать строку. Несоблюдение этого совета может
#	создать проблемы в работе. В некоторых случаях "none" подразумевает отсутствие
#	дефолтной установки совсем, в других случаях указывается существующая опция
#	"none" - комментарии к этому ключевому слову подскажут, где какой случай.
#
# Конфигурационные опции могут быть включены с использованием директивы "include". Эта
# директива берет список файлов для включения. Поддерживаются кавычки и маски символов.
#
# Например,
#
# include /path/to/included/file/squid.acl.config
#
# "Include"-ы могут быть вложены до жестко заданной глубины в 16 уровней. Это условное
# ограничение для предотвращения вхождения Squid-а в бесконечный цикл по вине рекурсивных
# "include"-ссылок на этапе загрузки конфигурационных файлов.
#

# OPTIONS FOR AUTHENTICATION (ОПЦИИ АУТЕНТИФИКАЦИИ)
# -----------------------------------------------------------------------------
#
#  TAG: auth_param
# Используется для определения параметров различных схем аутентификации
# поддерживаемых Squid-ом.
#	format: auth_param scheme parameter [setting]
#
# Порядок в котором схемы аутентификации представляются клиенту, зависит от порядка
# расположения схем в конфигурационном файле. Первая по порядку схема, будет
# представлена первой. IE имеет баг (конфликтующий с RFC 2617), связанный с тем, что
# он использует "basic"-схему авторизации, несмотря на то, что в списке есть более
# безопасные схемы. Рекомендуется использовать тот порядок схем, который установлен
# по умолчанию. Если другие браузеры имеют сложности ("не понимают" предлагаемые схемы),
# то установите "basic"-схему аутентификации первой в списке, либо закомментируйте
# строки с другими схемами.
#
# Полностью сконфигурированая схема аутентификации может быть отключена только после
# выключения и рестарта Squid-а.
#===^===
# Изменения могут быть сделаны "на лету" и активированы реконфигурацией Squid-а
# (командой "reconfigure"?). Например, Вы можете установить другой "хэлпер",
# но не расконфигурировать (отключить?) "хэлпер" полностью.
#Changes can be made on the fly and activated with a reconfigure. I.E. You can
#change to a different helper, but not unconfigure the helper completely.
#=======
#
# Запомните, хотя эта директива определяет как Squid проводит аутентификацию, это
# не ведет к автоматической активации аутентификации. Для использования аутентификации
# Вы должны дополнительно использовать ACL, основанный на логине в тэгах "http_access"
# ("proxy_auth", "proxy_auth_regex" или "external" (внешний аутентификатор)
# с использованием переменной %LOGIN, используемой в формате тэга).
#
# Браузер будет опрошен для авторизации первым же ACL, который встретится в процессе
# обработки тэга "http_access", а также будет повторно опрашиваться на наличие новых
# (других) учетных данных, если запрос был отклонен в "proxy_auth" ACL.
#
# Важно: Аутентификация не может быть использована при прозрачном проксировании,
# потому что клиент "думает", что работает с оригинальным сервером напрямую, а не через
# прокси. Это ограничение накладывает протокол TCP/IP, а не Squid. У портов, отмеченных
# флагами "transparent", "intercept" или "tproxy", аутентификация отключена.
#
#     === Опции для "basic"-схемы аутентификации ===
#
# "program" [команда]
# Определяет внешнюю программу, используемую для аутентификации. Такая программа
# считывает строку содержающую "username password" и отвечает "OK" или "ERR" в бесконечном
# цикле. Ответы "ERR" можно отследить исследуя описание ошибки, доступное в переменной %m
# на возвращенной (полученной) странице ошибки. Если Вы используете аутентификатор,
# удостоверьтесь, что Вы имеете (хотя бы) 1 ACL типа "proxy_auth".
#
# По умолчанию, "basic"-схема не используется, если не указана программа аутентификации.
#
# Если вы хотите использовать традиционную NCSA-аутентификацию прокси, введите в
# конфигурационный файл что-то вроде этого:
#	auth_param basic program /usr/local/libexec/ncsa_auth /usr/local/etc/passwd
#
# "utf8" [on|off]
# HTTP использует кодировку "iso-latin-1" в то время, когда некоторые программы
# аутентификации (например, LDAP) ожидают UTF-8. Если включить эту опцию, Squid будет
# транслировать "iso-latin-1" HTTP-запрос в UTF-8 перед тем, как передать "username"
# и "password" программе аутентификации.
#
# "children" [число]
# Количество процессов аутентификатора, которые могут быть запущены одновременно.
# Если их будет слишком мало, то каждый новый клиент, желающий получить доступ, будет
# ожидать пока не появится свободный процесс для аутентификации пользователя.
# Это замедляет работу Squid-а. Когда проверка пароля сделана через (медленно) сеть,
# возможно вы захотите увеличить число процессов-аутентификаторов.
#	auth_param basic children 5
#
# "concurrency" [число]
# Количество параллельных запросов (каналов), которые "хэлпер" может обрабатывать.
# По умолчанию 0, используется "хэлперами", которые поддерживают один запрос (канал)
# в единицу времени.
#
# Установка этого параметра изменяет протокол, используя включение номера канала
# в начало строки "запрос/ответ", что позволяет одновременно отсылать несколько запросов
# одному "хэлперу" без ожидания ответа. Изменение параметра возможно ТОЛЬКО если известно,
# что "хэлпер" поддерживает такой режим работы.
#	auth_param basic concurrency 0
#
# "realm" [строка]
# Определяет строку, которая будет отправлена пользователю в окне авторизации
# "basic"-схемы (часть текста, который увидит пользователь, получив запрос авторизации).
# Значение по умолчанию отсутствует. Может представлять собой название прокси сервера,
# например, "THE BEST proxy".
#	auth_param basic realm THE BEST proxy
#
# "credentialsttl" [время]
# Указывает Squid-у время валидности пары "username:password" для пользователей.
# Другими словами, как часто "хэлпер" будет повторять авторизацию пользователя.
# Установите маленькое значение, чтобы участить переавторизацию короткодействующих
# (short lived) паролей. Заметим, что установка большого значения не влияет на
# восприимчивость сервера к атакам, если вы используете систему одноразовых паролей
# (прим., SecureID). Даже используя такую систему, вы будете уязвимы к атакам, если
# Вы не будете дополнительно использовать ACL "max_user_ip" в "http_access".
#
# "casesensitive" [on|off]
# Определяет, являются ли "username" регистрозависимыми. Большинство баз данных
# регистро-НЕ-зависимы (т.е. считают слова user, USER и uSeR идентичными), позволяя
# использовать верхний и нижний регистры, но некоторые регистрозависимы. Это имеет
# большое значение для обработки "max_user_ip" и схожих с ним ACL.
#	auth_param basic casesensitive off
#
#
#     === Опции для "digest"-схемы аутентификации ===
#
# "program" [команда]
# Определяет программу, используемую для внешней аутентификации. Такая программа
# считывает строку содержащую "username":"realm" и отвечает соответствующим H(A1)
# значением в шестнадцатеричной системе ("hex"-код), если данные верны, или "ERR", если
# пользователь (или его H(A1) хэш) не существует. См. в RFC 2616 как определяется H(A1).
# Ответ "ERR" можно отследить исследуя описание ошибки, доступное в переменной %m
# на возвращенной (полученной) странице ошибки.
#
# По умолчанию, если не указана программа аутентификации, "digest"-схема не используется.
#
# Если вы хотите использовать "digest"-аутентификацию введите в конфигурационный файл
# что-то вроде этого:
#	auth_param digest program /usr/local/bin/digest_pw_auth /usr/local/etc/digpass
#
# "utf8" [on|off]
# HTTP использует кодировку iso-latin-1, в то время как некоторые движки аутентификации,
# такие как LDAP, ожидают UTF-8. Если эта опция включена, Squid будет транслировать
# HTTP iso-latin-1 в UTF-8 перед отправкой имени пользователя и пароля "хэлперу".
#
# "children" [число]
# Количество порождаемых процессов аутентификатора (значения по умолчанию нет).
# Если указать слишком малое число, Squid будет ждать их (освобождения) для обработки
# накопившихся H(A1) расчетов, что будет его тормозить. Когда H(A1) расчеты производятся
# через (медленно) сеть, вам, вероятно, потребуется больше процессов аутентификатора.
#	auth_param digest children 5
#
# "realm" [строка]
# Определяет "realm"-имя, которое будет сообщено клиенту для схемы "digest"-аутентификации
# (часть текста пользователь увидит при появлении запроса имени пользователя и пароля).
# Значения по умолчанию нет.
#	auth_param digest realm Squid proxy-caching web server
#
# [z_ЛИРИКА: Nonce.
# http://etutorials.org/Server+Administration/Squid.+The+definitive+guide/Chapter+12.+Authentication+Helpers/12.3+HTTP+Digest+Authentication/.
# Все уникальные параметры, относящиеся к использованию "Digest"-аутентификации, используют
# нечто, именуемое "nonce". Nonce - специальная строка данных, которая время от времени
# изменяется. Во время процесса аутентификации, сервер (в данном случае Squid)
# предоставляет "nonce"-значение клиенту. Клиент использует его при генерации дайджеста.
# Без данных "nonce", злоумышленник может просто перехватить и воспроизвести дайджест,
# чтобы получить доступ к Squid.]
#
# "nonce_garbage_interval" [время]
# Определяет временной интервал, в течение которого "nonce"-ы, отправленные к
# "client_agent"-ам проверяются на валидность.
#
# "nonce_max_duration" [время]
# Определяет максимальное время, в течение которого отправленные "nonce"-ы будут
# действительны.
#
# "nonce_max_count" [число]
# Определяет сколько раз (макс.) может быть использован отданный "nonce".
#
# "nonce_strictness" [on|off]
#===^===
# Определяет, будет ли Squid требовать строгого "приращения-на-единицу" для подсчета
# "nonce", или простого приращения (состояние "off" - для случаев когда сгенерированный
# пользовательским агентом сигнал об использовании "nonce" теряет 1 (т.е., 1,2,4,6)).
# По умолчанию выключено.
#Determines if squid requires strict increment-by-1 behavior for nonce counts,
#or just incrementing (off - for use when  useragents generate nonce counts that
#occasionally miss 1(ie, 1,2,4,6)).
#=======
# [z_ЛИРИКА: Nonce (дополнение).
# http://etutorials.org/Server+Administration/Squid.+The+definitive+guide/Chapter+12.+Authentication+Helpers/12.3+HTTP+Digest+Authentication/.
# При установке "on" Squid возвращает ответ "401", если значение "nonce" не равно
# 'предыдущее значение + 1'. При отключении Squid допускает в значениях "nonce" пробелы.] 
#
# "check_nonce_count" [on|off]
# Если опция установлена в "off", то для обхода ошибок реализации "qop" дайджест-схемы
# в некоторых версиях популярного браузера полностью отключается проверка счетчика "nonce".
# По умолчанию подсчет "nonce" включен для защиты от атак связанных с подбором
# аутентификационных данных.
#
# "post_workaround" [on|off]
#===^===
# Обходной путь для некоторых бажных браузеров, которые отсылают некорректные
# "digest"-запросы в POST-запросах при повторном использовании тех же "nonce" как
# полученных ранее на GET-запрос.
#This is a workaround to certain buggy browsers who sends an incorrect request digest
#in POST requests when reusing the same nonce as acquired earlier on a GET request.
#=======
#
#     === Опции для NTLM-схемы аутентификации ===
#
# "program" [команда]
# Определяет команду внешнего NTLM-аутентификатора. Такая программа считывает обмен
# NTLMSSP-пакетами с браузером через Squid до завершения аутентификации. Если Вы
# используете NTLM-аутентификатор, удостоверьтесь, что имеете хотя бы один "proxy_auth"
# ACL. По умолчанию NTLM-аутентификатор не используется.
#	auth_param ntlm program /usr/local/bin/ntlm_auth
#
#  "children" [число]
# Количество порождаемых процессов аутентификатора (значения по умолчанию нет).
# Если указать слишком малое число, Squid будет ждать их (освобождения) для обработки
# накопившихся учетных данных, что будет его тормозить. Когда проверка учетных данных
# производится через (медленно) сеть, вам, вероятно, потребуется больше процессов
# аутентификатора.
#	auth_param ntlm children 5
#
# "keep_alive" [on|off]
# Определяет, хранить ли соединение открытым после начального ответа, в котором Squid
# сообщает браузеру, какие схемы поддерживаются прокси-сервером. Некоторые браузеры,
# как известно, открывают несколько окон авторизации или искажают передачу
# POST/PUT-запросов если соединение не закрыто. Во избежание этого по умолчанию опция
# выключена, но это можно изменить.
#	auth_param ntlm keep_alive on
#
#     === Опции для Negotiate-схемы аутентификации ===
#
# "program" [команда]
# Определяет команду внешнего Negotiate-аутентификатора.
#===^===
# Этот протокол используется в средах, где присутствует Microsoft Active
# Directory совместно с браузерами MSIE либо Mozilla Firefox.
#This protocol is used in Microsoft Active-Directory enabled setups with
#the Microsoft Internet Explorer or Mozilla Firefox browsers.
#=======
# Его главная цель состоит в обмене учетными данными со Squid-ом, используя механизмы
# Kerberos.
# Если Вы используете Negotiate-аутентификатор, убедитесь, что вы имеете, по крайней мере
# один активный ACL типа "proxy_auth". По умолчанию Negotiate-аутентификатор
# не используется. Программы, подходящие для этой роли, поставляются только в составе
# Samba версии 4 или позже.
#	auth_param negotiate program /usr/local/bin/ntlm_auth --helper-protocol=gss-spnego
#
# "children" [число]
# Количество порождаемых процессов аутентификатора (значения по умолчанию нет).
# Если указать слишком малое число, Squid будет ждать их (освобождения) для обработки
# накопившихся учетных данных, что будет его тормозить. Когда проверка учетных данных
# производится через (медленно) сеть, вам, вероятно, потребуется больше процессов
# аутентификатора.
#	auth_param negotiate children 5
#
# "keep_alive" [on|off]
# Определяет, сохранять ли соединение открытым после инициирующего ответа, в котором Squid
# сообщает браузеру, какие схемы (аутентификации) поддерживаются прокси-сервером.
# Некоторые браузеры, как известно, открывают несколько окон авторизации  или искажают
# передачу POST/PUT-запросов если соединение не закрыто. Во избежание этого по умолчанию
# опция выключена, но это можно изменить.
# [z_ЛИРИКА: Несмотря на утверждение в предыдущей строке, в оригинальном конфиге параметр
# по умолчанию включен!!!]
#	auth_param negotiate keep_alive on
#
# Примеры:
#
# Рекомендуемые минимальные параметры настройки для каждой из схем аутентификации:
#
##auth_param negotiate program <Для активации раскомментировать и заполнить эту строку>
##auth_param negotiate children 5
##auth_param negotiate keep_alive on
##
##auth_param ntlm program <Для активации раскомментировать и заполнить эту строку>
##auth_param ntlm children 5
##auth_param ntlm keep_alive on
##
##auth_param digest program <Для активации раскомментировать и заполнить эту строку>
##auth_param digest children 5
##auth_param digest realm Squid proxy-caching web server
##auth_param digest nonce_garbage_interval 5 minutes
##auth_param digest nonce_max_duration 30 minutes
##auth_param digest nonce_max_count 50
##
##auth_param basic program <Для активации раскомментировать и заполнить эту строку>
##auth_param basic children 5
##auth_param basic realm Squid proxy-caching web server
##auth_param basic credentialsttl 2 hours
#
#Default:
# none
#
# authenticate_cache_garbage_interval [время]
# Определяет период времени между "сборками мусора" в "username"-кэше.
# Это компромисс между утилизацией памяти (длительные промежутки - скажем, 2 дня)
# и процессора (короткие промежутки - скажем, 1 минуту). Изменять только при наличии
# веских причин.
#	authenticate_cache_garbage_interval 1 hour
#
# authenticate_ttl [время]
# Определяет время, которое пользователь и его учетные данные будут оставаться
# аутентифицированными в пользовательском кэше со времени их последнего запроса.
# Когда подойдет время "сборки мусора", все учетные данные пользователя, у которых
# закончился TTL, будут удалены из памяти.
#	authenticate_ttl 1 hour
#
# authenticate_ip_ttl [время]
# Если вы используете прокси-аутентификацию и "max_user_ip" ACL, то этот тэг определяет,
# как долго Squid будет помнить IP-адреса ассоциированые с каждым пользователем.
# Используйте небольшое значение (например, 60 секунд), если ваши пользователи могут
# быстро менять IP-адреса, как в случае "dial up". Вы можете обезопаситься, используя
# большое значение (например, 2 часа) в корпоративной  LAN со статической IP-адресацией.
#Default:
#	authenticate_ip_ttl 0 seconds
#
#
# ACCESS CONTROLS (КОНТРОЛЬ ДОСТУПА)
# -----------------------------------------------------------------------------
#
# external_acl_type
# Определяет внешние ACL-классы, использующие программы-"хэлперы" для просмотра статуса.
#	external_acl_type name [опции] FORMAT.. /path/to/helper [аргументы "хэлпера"..]
# Опции:
#	ttl=n	TTL в секундах для кэширования результатов
#		(по умолчанию 3600 сек., т.е. 1 час).
#	negative_ttl=n
#		TTL для кэширования отрицательных "lookup"-ов.
#		(По умолчанию как у ttl)
#	children=n
#		Количество "хэлпер"-процессов, порождаемых для обслуживания внешних
#		ACL-поисков такого типа. (По умолчанию 5).
#	concurrency=n
#		Уровень параллельности для процесса. Используется только с "хэлперами",
#		умеющими обрабатывать более одного запроса одновременно.
#	cache=n	Размер кэша результатов, 0 - неограничено (по умолчанию).
#	grace=n	Процент остатка от TTL, когда должно быть инициировано обновление
#		кэшированных записей без необходимости ожидания нового ответа.
#		(по умолчанию 0, льготный период отсутствует).
#	protocol=2.5
#		Режим совместимости внешних ACL со Squid-2.5.
#	ipv4/ipv6
#		IP-режим используется для коммуникации с этим "хэлпером". Для
#		совместимости со старыми конфигурациями и "хэлперами" в настоящее время
#		по умолчанию используется "ipv4".
#
# Спецификации формата:
#	%LOGIN		Логин аутентифицированного пользователя
#	%EXT_USER	Имя пользователя из внешнего acl
#	%IDENT		"Ident"-имя пользователя
#	%SRC		IP-адрес клиента
#	%SRCPORT 	Порт клиента
#	%URI		Запрашиваемый URI
#	%DST		Запрошенный хост
#	%PROTO		Протокол, по которому сделан запрос
#	%PORT		Запрошенный порт
#	%PATH		Запрашиваемый URL
#	%METHOD		Метод, которым осуществлен запрос
#	%MYADDR		IP-адрес интерфейса, на котором Squid слушает запросы
#	%MYPORT		Номер порта Squid (http_port)
#	%PATH		Запрашиваемый URL-path (включая строку запроса, если есть)
#	%USER_CERT	Пользовательский SSL-сертификат в PEM-формате
#	%USER_CERTCHAIN	Цепочка пользовательских SSL-сертификатов в PEM-формате
#	%USER_CERT_xx	Атрибуты (хх) владельца пользовательского SSL-сертификата
#	%USER_CA_xx	Атрибуты (хх) эмитента (кем выдан) пользовательского
#			SSL-сертификата
#	%>{Header}	HTTP-заголовок запроса "Header"
#	%>{Hdr:member}	HTTP-заголовок запроса "Hdr" + перечень членов ("list member")
#			"member"
#	%>{Hdr:;member}	HTTP-заголовок запроса, содержащий перечень "member", разделённых
#			символом ";". Разделителем может быть любой не буквенно-цифровой
#			символ.
#	%<{Header}	HTTP-заголовок ответа "Header"
#	%<{Hdr:member}	HTTP-заголовок ответа "Hdr" + перечень членов ("list member")
#			"member"
#	%<{Hdr:;member}	HTTP-заголовок ответа, содержащий перечень "member", разделённых
#			символом ";". Разделителем может быть любой не буквенно-цифровой
#			символ.
#
# В дополнение к вышесказанному, любая строка определенная в ACL, так же будет включена
# в строку запроса "хэлпера", после указания форматов (см. "acl external").
#
# "Хэлпер" получает строки вышеуказанного формата (cм. Спецификации формата) и возвращает
# строки начинающиеся с "OK" или "ERR", определяющие валидность запроса, и, возможно,
# строки будут содержать дополнительные ключевые слова ("keywords") с более подробной
# информацией.
# Синтаксис результата:
#	OK/ERR keyword=value ...
#
# Определенные ключевые слова:
#	user=		Имя пользователя (логин)
#	password=	Пароль пользователя (см. опцию "login=" тэга "cache_peer")
#	message= 	Сообщение, описывающее причину (ошибку?). Доступно в переменной %o
#			на страницах ошибок.
#	tag=		Добавляет тэг к запросу (для обоих результатов "ERR/OK")
#			Только устанавливает тег, не изменяя существующие.
#	log=		Строка, которая будет записана в "access.log". Доступна как %ea
#			в специкации формата журналов ("logformat").
#
# Если установлено protocol=3.0 (по умолчанию), тогда маскирование/экранирование
# ("escaping") URL будет использоваться для защиты каждого значения и для запросов,
# и для ответов.
#
# Если используется protocol=2.5, тогда все значения, которые могут содержать пробелы,
# должны быть закрыты кавычками, иначе пробелы должны экранироваться символом "\".
# Кавычки и слэши, содержащиеся в ключевом слове, так же должны экранироваться "\".
#
# Когда используется опция "concurrency=", протокол меняется путем внедрения тэга
# "query channel" (запрос канала) перед запросом/ответом. Тег "query channel" - число
# между 0 и "concurrency-1".
#
# Установки по умолчанию:
# none
#
# acl
# Позволяет определять ACL.
#
# Каждое определение ACL должно начинаться с имени и типа ACL, за которыми следуют
# аргументы, специфичные для указанного типа ACL, либо имя файла (в кавычках),
# из которого эти аргументы считываются.
#	acl aclname acltype string1 ...
#	acl aclname acltype "file" ...
#
# Когда используется "file", то файл должен содержать один элемент на строку.
#
# По умолчанию регулярные выражения РЕГИСТРОЗАВИСИМЫ. Cделать их регистроНЕзависимыми
# можно используя опцию -i.
#
# Некоторые типы ACL требуют приостановления текущего запроса, чтобы получить доступ
# к некоторым внешним источникам данных. Те типы ACL, которые приостанавливают запросы,
# помечены тегом "[slow]", а которые не останавливают - помечены тэгом "[fast]".
# См. http://wiki.squid-cache.org/SquidFaq/SquidAcl
#
#
#	***** ДОСТУПНЫЕ ТИПЫ ACL *****
#
#	acl aclname src ip-address/netmask ...	(Проверяет) IP-адрес клиента [fast]
#	acl aclname src addr1-addr2/netmask ...	(Проверяет) диапазон IP-адресов [fast]
#	acl aclname dst ip-address/netmask ...	(Проверяет) IP-адрес URL-а хоста [slow]
#	acl aclname myip ip-address/netmask ...	(Проверяет) локальный IP-адрес [fast]
#
#	acl aclname arp mac-address ... (xx:xx:xx:xx:xx:xx notation)
# Проверяет MAC адрес [fast].
# arp ACL требует компиляции Squid-а с опцией --enable-arp-acl.
# Кроме того, код ARP ACL переносится не на все операционные системы. Он работает на
# Linux, Solaris, Windows, FreeBSD, и некоторых других BSD-системах.
#
# Примечание: Squid может определять MAC-адреса только тех клиентов, которые находятся
# с ним в одной подсети. Если клиент находится в другой подсети, то Squid не сможет
# определить его MAC-адрес.
#
#	acl aclname srcdomain .foo.com ...
#	Проверяет доменное имя исходя из клиентского IP [slow]
#	acl aclname dstdomain .foo.com ...
#	Проверяет доменное имя сервера назначения исходя из URL [fast]
#	acl aclname srcdom_regex [-i] \.foo\.com ...
#	Регулярное выражение, совпадающее с доменным именем клиента [slow]
#	acl aclname dstdom_regex [-i] \.foo\.com ...
#	Регулярное выражение, совпадающее с доменным именем сервера назначения [fast]
#
# Обратный поиск ("reverse lookup") для "dstdomain" и "dstdom_regex" проводится если
# используется URL, основанный на IP, и совпадение не будет найдено. В случае неудачного
# "reverse lookup"-а используется имя "none".
#
#	acl aclname src_as number ...
#	acl aclname dst_as number ...
#	[fast]
# За исключением контроля доступа, AS-номера могут быть использованы для перенаправления
# запросов к указанным кэшам. Вот пример перенаправления на "mycache.mydomain.net" только
# тех запросов, которые совпадают с "dst_as 1241":
#	acl asexample dst_as 1241
#	cache_peer_access mycache.mydomain.net allow asexample
#	cache_peer_access mycache_mydomain.net deny all
#
#	acl aclname peername myPeer ...
#	[fast]
# Соответствие опции "name" в блоке "cache_peer". Для надежного использования необходимо
# установить эту опцию.
#
#	acl aclname time     [day-abbrevs]  [h1:m1-h2:m2]
#	Проверяет время [fast]
#	Аббревиатуры дней:	S-Вск, M-Пон, T-Вт, W-Ср, H-Чт, F-Пт, A-Сб.
#	h1:m1 должно быть меньше h2:m2
#
#	acl aclname url_regex [-i] ^http:// ...
#	Регулярное выражение, совпадающее с полным URL [fast].
#
#	acl aclname urlpath_regex [-i] \.gif$ ...
#	Регулярное выражение, совпадающее с URL-путём [fast].
#
#	acl aclname port 80 70 21 0-1024...
#	Проверяет TCP-порты назначения.
#	Поддерживаются диапазоны портов [fast].
#
#	acl aclname myport 3128 ...
#	Проверяет локальный TCP-порт [fast]
#
#	acl aclname myportname 3128 ...
#	Проверяет имя локального порта http(s) [fast]
#
#	acl aclname proto HTTP FTP ...
#	Проверяет протокол запроса [fast]
#
#	acl aclname method GET POST ...
#	Проверяет метод HTTP-запроса [fast]
#
#	acl aclname http_status 200 301 500- 400-403 ...
#	Проверяет HTTP-код ответа [fast]
#
#	acl aclname browser [-i] regexp ...
#	Проверяет "User-Agent"-заголовок по регекспу (см. также "req_header") [fast]
#
#	acl aclname referer_regex [-i] regexp ...
#	Проверяет "Referer"-заголовок по регекспу.
#	"Referer" очень ненадежен, поэтому используйте этот тип ACL осторожно [fast]
#
#	acl aclname ident username ...
#	acl aclname ident_regex [-i] pattern ...
#	Проверяет на совпадение выходные данные "ident" [slow].
#	Используйте REQUIRED для принятия любых ненулевых "ident"-строк.
# [z_ЛИРИКА: См. здесь (6.1.2.11 ident).
# http://etutorials.org/Server+Administration/Squid.+The+definitive+guide/Chapter+6.+All+About+Access+Controls/6.1+Access+Control+Elements/.
# Squid может узнать имя пользователя через "ident"-протокол (RFC 1413) или через
# аутентификационный HTTP-заголовок.]
#
#	acl aclname proxy_auth [-i] username ...
#	acl aclname proxy_auth_regex [-i] pattern ...
#	Выполняет HTTP-запрос аутентификации клиента и проверяет предоставленные
#	учетные данные [slow]
#
#	Берет список разрешенных пользовательских имен.
#	Используйте REQUIRED, чтобы принимать любое допустимое имя пользователя.
#
#	Будет использовать прокси-аутентификацию в "forward-proxy"-сценариях, и простую
#	HTTP-аутентификацию в "reverse-proxy"-сценариях.
#
#	Примечание: Если "Proxy-Authentication"-заголовок отправлен, но не используется
#	в ACL для проверки, то имя пользователя НЕ вносится в access.log
#
#	Примечание: "proxy_auth" требует внешнюю программу аутентификации для
#	проверки пары логин/пароль (см. опцию "auth_param").
#
#	Примечание: "proxy_auth" не может быть использован при прозрачном/перехватывающем
#	проксировании, т.к. браузер должен быть настроен на использование прокси,
#	чтобы отвечать на аутентификационные запросы прокси-сервера.
#
#	acl aclname snmp_community string ...
#	"Community"-строка для ограничения доступа к Вашему SNMP агенту [fast].
#	Пример:
#	acl snmppublic snmp_community public
# [z_ЛИРИКА: См. здесь (6.1.2.15 snmp_community).
# http://etutorials.org/Server+Administration/Squid.+The+definitive+guide/Chapter+6.+All+About+Access+Controls/6.1+Access+Control+Elements/. ]
#
#	acl aclname maxconn number
#	Срабатывает когда количество установленных HTTP-соединений с IP-адреса клиента
#	больше чем "number". [fast]
#
#	acl aclname max_user_ip [-s] number
#	Срабатывает когда пользователь пытается залогиниться более чем с "number"
#	различных IP-адресов одновременно. Параметр "authenticate_ip_ttl" контролирует
#	таймаут каждого IP-адреса [fast].
#	Если указан агрумент -s, то лимит будет строгим, запрещающим выход через прокси
#	с любых других IP-адресов, пока "ttl" не истечет. Без этого аргумента (-s) Squid
#	будет просто раздражать пользователя "произвольным" отклонением запросов
#	(счетчик сбрасывается каждый раз, когда достигнут лимит и запрос отклонен).
#	Примечание: в режиме "acceleration" или в сети "child"-прокси, может показаться,
#	что клиент приходит с нескольких IP-адресов, если он идет через "proxy farms",
#	тогда ограничение в 1 IP-адрес на клиента может вызвать проблемы у пользователя.
#
#	acl aclname req_mime_type [-i] mime-type ...
#	Регулярное выражение, проверяющее "mime"-тип клиентского запроса. Может
#	использоваться для обнаружения отправки файла или некоторых типов
#	HTTP-туннелирования [fast].
#	Примечание: НЕ проверяет ответ. Вы не можете использовать этот ACL
#	для проверки возвращаемого типа файла.
#
#	acl aclname req_header header-name [-i] any\.regex\.here
#	Регулярное выражение, проверяющее любой из известных заголовков запросов.
#	Можно рассматривать как сверх-набор из ACL "browser", "referer" и "mime-type".
#	[fast]
#
#	acl aclname rep_mime_type [-i] mime-type ...
#	Регулярное выражение, проверяющее "mime"-тип ответа полученный Squid-ом. Может
#	использоваться для обнаружения скачивания файла или некоторых типов
#	HTTP-туннелированных запросов. [fast]
#	Примечание: Не действует в правилах "http_access". Действует только в правилах,
#	которые влияют на данные ответа, таких как "http_reply_access".
#
#	acl aclname rep_header header-name [-i] any\.regex\.here
#	Регулярное выражение, проверяющее любые из известных заголовков ответов.
#	Можно рассматривать как сверх-набор из ACL "browser", "referer" и "mime-type".
#	[fast]
#
#	acl aclname external class_name [arguments...]
#	Поиск внешних ACL по классу "хэлпера", определенному директивой "external_acl_type".
#	[slow]
#
#	acl aclname user_cert attribute values...
#	Проверяет атрибуты в пользовательском SSL-сертификате.
#	Атрибутом может быть один из DN/C/O/CN/L/ST [fast].
#
#	acl aclname ca_cert attribute values...
#	Проверяет атрибуты лица, выдавшего SSL-сертификат.
#	Атрибутом может быть один из DN/C/O/CN/L/ST. [fast]
#
#	acl aclname ext_user username ...
#	acl aclname ext_user_regex [-i] pattern ...
#	Проверяет имя пользователя, возвращенное внешним ACL-"хэлпером". [slow]
#	Для разрешения любого не пустого имени пользователя используйте REQUIRED.
#
#	acl aclname tag tagvalue ...
#	Проверка строки в теге возвращенном внешним ACL-"хэлпером". [slow]
#
#	Примеры:
#		acl macaddress arp 09:00:2b:23:45:67
#		acl myexample dst_as 1241
#		acl password proxy_auth REQUIRED
#		acl fileupload req_mime_type -i ^multipart/form-data$
#		acl javascript rep_mime_type -i ^application/x-javascript$
#
# Установки по умолчанию:
# acl all src all
#
#
# Рекомендуемая минимальная конфигурация:
#
acl manager proto cache_object
acl localhost src 127.0.0.1/32 ::1
acl to_localhost dst 127.0.0.0/8 0.0.0.0/32 ::1
#
# Правила-пример, разрешающие доступ из Ваших локальных сетей.
# Измените их согласно списку Ваших (внутренних) IP-сетей, откуда будет разрешен
# доступ через прокси-сервер.
acl localnet src 10.0.0.0/8	# Возможные адреса локальных сетей согласно RFC1918.
acl localnet src 172.16.0.0/12	# ===/===/===/===/===/===/===/===/===/===/===/===/===
acl localnet src 192.168.0.0/16	# ===/===/===/===/===/===/===/===/===/===/===/===/===
acl localnet src fc00::/7 	# Сайт-локальные IPv6-юникаст адреса (см. RFC 4193)
acl localnet src fe80::/10	# Линк-локальные IPv6-юникаст адреса (прямого подключения)
                                # (см. RFC 4291)

acl SSL_ports port 443
acl Safe_ports port 80		# http
acl Safe_ports port 21		# ftp
acl Safe_ports port 443		# https
acl Safe_ports port 70		# gopher
acl Safe_ports port 210		# wais
acl Safe_ports port 1025-65535	# unregistered ports
acl Safe_ports port 280		# http-mgmt
acl Safe_ports port 488		# gss-http
acl Safe_ports port 591		# filemaker
acl Safe_ports port 777		# multiling http
acl CONNECT method CONNECT

# TAG: follow_x_forwarded_for
# Разрешает/запрещает "X-Forwarded-For"-заголовок, которому надлежит следовать, чтобы
# найти оригинальный источник запроса.
#
# Запросы могут пройти через цепочку других прокси прежде, чем достигнут нас.
# "X-Forwarded-For"-заголовок будет содержать список IP-адресов, разделенных запятыми.
# Самым правым адресом является последний пройденый.
#
# Если запрос пришел к нам из источника, который разрешен этим конфигурационным
# параметром, то мы будем смотреть "X-Forwarded-For"-заголовок, чтобы узнать,
# откуда пришел запрос. Если "X-Forwarded-For"-заголовок содержит несколько IP-адресов,
# мы будем идти по этому списку снизу вверх (отслеживать в обратном порядке), пока
# не достигнем адреса, за которым следование "X-Forwarded-For"-заголовку запрещено,
# или пока не достигнем первого адреса в списке. Для целей ACL, используемых в
# "follow_x_forwarded_for"-директиве, "src" ACL всегда совпадает с адресом, который
# мы тестируем, и "srcdomain" соответствует его rDNS.
#
# Конечным результатом этого процесса является IP-адрес, на который мы будем ссылаться
# как на косвенный адрес клиента. Этот адрес можно рассматривать как адрес клиента для
# контроля доступа, ICAP, "delay pools" и логирования, в зависимости от опций
# "acl_uses_indirect_client", "icap_uses_indirect_client",
# "delay_pool_uses_indirect_client" и "log_uses_indirect_client".
#
# Поддерживает только быстрые [fast] типы acl.
# См. http://wiki.squid-cache.org/SquidFaq/SquidAcl
#
#	БЕЗОПАСНОСТЬ:
# Любой хост, на который мы следуем по "X-Forwarded-For"-заголовку, может разместить
# в заголовке неверную информацию, и Squid будет использовать ее так, как если бы
# это был адрес источника запроса (корректная информация). Это позволяет удаленному
# хосту обойти любые ограничения контроля доступа, основанные на источнике адресов клиента
# (client's source addresses).
#
# Примеры:
#	acl localhost src 127.0.0.1
#	acl my_other_proxy srcdomain .proxy.example.com
#	follow_x_forwarded_for allow localhost
#	follow_x_forwarded_for allow my_other_proxy
#
# Установки по умолчанию:
# follow_x_forwarded_for deny all
#
# TAG: acl_uses_indirect_client	on|off
#
# Определяет, может ли использоваться косвенный адрес клиента
# (см. "follow_x_forwarded_for") вместо прямого адреса клиента в совпадающем acl.
#
# Установки по умолчанию:
# acl_uses_indirect_client on
#
# TAG: delay_pool_uses_indirect_client	on|off
#
# Определяет, может ли использоваться в "delay pools" косвенный адрес клиента
# вместо прямого (см. "follow_x_forwarded_for").
#
# Установки по умолчанию:
# delay_pool_uses_indirect_client on
#
# TAG: log_uses_indirect_client	on|off
#
# Определяет, может ли использоваться в "access"-логе ("access log") косвенный адрес
# клиента вместо прямого (см. "follow_x_forwarded_for").
#
# Установки по умолчанию:
# log_uses_indirect_client on
#
#
# TAG: http_access
#
# Разрешает или запрещает доступ, основываясь на созданных ACL.
#
# Использование:
# http_access allow|deny [!]aclname ...
#
# Примечание к значениям по умолчанию:
# Если отсутствует указание "allow", то по умолчанию будет принято "deny".
#
# Если ни одно "access"-правило не совпало, то по умолчанию будет использоваться
# правило, противоположное последнему в списке.  Если последняя строка была "deny",
# то умолчание будет "allow". И наоборот, если последняя строка была "allow",
# то умолчание будет "deny". Исходя из этого, во избежание путаницы, имеет смысл
# установить в конце списка ваших ACL правило "deny all".
#
# Поддерживает быстрые [fast] и медленные [slow] типы acl.
# См. http://wiki.squid-cache.org/SquidFaq/SquidAcl
#
# По умолчанию:
# http_access deny all
#
#
# Рекомендуемая минимальная конфигурация прав доступа:
#
# Доступ к "cachemgr" только с localhost
http_access allow manager localhost
http_access deny manager
#
# Запрет на запросы к определенно небезопасным портам.
http_access deny !Safe_ports
#
# Запрет на использование метода CONNECT с не-SSL портами.
http_access deny CONNECT !SSL_ports
#
# Настоятельно рекомендуем раскомментировать нижеследующий тэг для защиты "невинных"
# веб-приложений, запущеных на прокси-сервере, который думает, что локальный пользователь
# единственный, кто имеет доступ к сервисам локалхоста.
#
#http_access deny to_localhost
#
# СОБСТВЕННЫЕ ПРАВИЛА ДЛЯ РАЗРЕШЕНИЯ ДОСТУПА ВАШИМ КЛИЕНТАМ ВСТАВЛЯТЬ ЗДЕСЬ
#
# Пример правила, разрешающего доступ из вашей локальной сети. Измените в ACL "localnet"
# IP-адреса под свои локальные сети, для которых будет предоставлятся доступ.
#
http_access allow localnet
http_access allow localhost
#
# И в окончание закрыть любой другой доступ к этому прокси-серверу.
http_access deny all
#
#  TAG: adapted_http_access
# Разрешает/запрещает доступ, основанный на определенных ACL. По сути идентично
# "http_access", но срабатывает после редиректоров и ICAP/eCAP адаптации. Разрешение
# управления доступом основано на их выводе.
#
# Если не установлено - используется только "http_access".
#
# Установки по умолчанию:
# none
#
#  TAG: http_reply_access
# Разрешает ответы на запросы клиентов. Является дополнением к тэгу "http_access".
#	http_reply_access allow|deny [!] aclname ...
#
# Примечание: Если в ACL не используется, то по умолчанию разрешено отвечать
# на все запросы.
#
# Если ни один ACL данного тэга не совпал, будет использоваться политика, противоположная
# указанной в последней строке [z_ЛИРИКА: см. похожее в "http_access"]. Т.о., хорошей
# практикой является завершение набора правил директивой "allow all" или "deny all".
#
# Поддерживает быстрые [fast] и медленные [slow] типы acl.
# См. http://wiki.squid-cache.org/SquidFaq/SquidAcl
#
# Установки по умолчанию:
# none
#
#  TAG: icp_access
# Разрешает/запрещает доступ по ICP-порту, основываясь на указанных ACL.
#
#	icp_access  allow|deny [!]aclname ...
#
# См. http_access
#
# Поддерживает только быстрые [fast] типы acl.
# См. http://wiki.squid-cache.org/SquidFaq/SquidAcl
#
# Пример:
## Разрешает ICP-запросы только из локальной сети
##icp_access allow localnet
##icp_access deny all
#
# Установки по умолчанию:
# icp_access deny all
#
#  TAG: htcp_access
# Разрешает/запрещает доступ по HTCP-порту, основываясь на указанных ACL.
#
#	htcp_access  allow|deny [!]aclname ...
#
# См. http_access
#
# Примечание: По умолчанию, если "htcp_access" ACL отсутствуют, весь траффик
# (по HTCP порту?) запрещен. Это умолчание может быть причиной проблем с пирами,
# использующими опции "htcp" или "htcp-oldsquid".
#
# Поддерживает только быстрые [fast] типы acl.
# См. http://wiki.squid-cache.org/SquidFaq/SquidAcl
#
# Пример:
# Разрешает HTCP-запросы только из локальной сети.
##htcp_access allow localnet
##htcp_access deny all
#
# Установки по умолчанию:
# htcp_access deny all
#
#
# TAG: htcp_clr_access
# Основываясь на указанных ACL, разрешает/запрещает доступ к функции очистки содержимого,
# используя HTCP.
#
#	htcp_clr_access  allow|deny [!]aclname ...
#
# См. http_access
#
# Поддерживает только быстрые [fast] типы acl.
# См. http://wiki.squid-cache.org/SquidFaq/SquidAcl
#
# Пример:
##Разрешает HTCP CLR запросы от доверенных пиров.
#acl htcp_clr_peer src 172.16.1.2
#htcp_clr_access allow htcp_clr_peer
#
# Установки по умолчанию:
# htcp_clr_access deny all
#
#
#  TAG: miss_access
# Используйте, чтобы заставить ваших "соседей" (neighbors) использовать вас как
# "брата" (sibling), а не "родителя" (parent). Например:
#	acl localclients src 172.16.0.0/16
#	miss_access allow localclients
#	miss_access deny  !localclients
#
# Это значит, что только вашим локальным клиентам разрешено получать MISSES (объект не
# найден в кэше), а все остальные клиенты будут получать только HITS (попадание в кэш).
#
# По умолчанию позволяет всем клиентам, прошедшим правила "http_access", получать от нас
# MISSES.
#
# Поддерживает только быстрые [fast] типы acl.
# См. http://wiki.squid-cache.org/SquidFaq/SquidAcl
#
# Установки по умолчанию:
# miss_access allow all
#
#
#  TAG: ident_lookup_access
#
# Список элементов ACL, которые, при совпадении, являются причиной "ident"-поиска (см.
# RFC 931) для выполнения этого запроса. Например, Вы можете выбрать постоянное
# выполнение "ident"-поиска для Вашего основного многопользовательского Unix-компьютера,
# но не для Ваших Маков и ПК. По умолчанию для любых запросов "ident"-поиск не выполняется.
#
# Для включения "ident"-поиска указанных адресов клиента Вы можете последовать
# этому примеру:
#	acl ident_aware_hosts src 198.168.1.0/24
#	ident_lookup_access allow ident_aware_hosts
#	ident_lookup_access deny all
#
# Полностью поддерживается проверка только ACL "src"-типа. ACL "src_domain"-типа
# (в оригинале "srcdomain") может работать, но не всегда предоставляет корректные
# результаты.
#
# Поддерживает только быстрые [fast] типы acl.
# См. http://wiki.squid-cache.org/SquidFaq/SquidAcl
#
# Установки по умолчанию:
# ident_lookup_access deny all
#
#
#  TAG: reply_body_max_size	size [acl acl...]
#
# Определяет максимальный размер тела ответа (в байтах?). Это можно использовать
# для предотвращения закачки пользователем очень больших файлов, таких как MP3 и фильмы.
# При получении заголовков ответа происходит обработка строк "reply_body_max_size",
# и первая строка, где все (если есть) перечисленные ACL совпадают, используется как
# максимальный размер тела для этого ответа.
#
# Этот размер проверяется дважды. Сначала, когда мы получаем заголовки ответов, мы
# проверяем значение "content-length" (размер содержимого). Если значение "content-length"
# присутствует и оно больше разрешенного размера, то запрос блокируется и пользователь
# получает сообщение об ошибке, которое гласит "the request or reply is too large"
# (Запрос или ответ слишком большой). Если "content-length" отсутствует и размер
# ответа превышает этот лимит, то клиентские соединения просто закрываются и клиенты
# получают частичный ответ.
#
# ВНИМАНИЕ: Если "content-length" отсутствует в заголовке, то, возможно, подчиненые кэши
# не смогут определить частичный ответ, и таким образом будут кэшировать частичные ответы
# и будут отдавать их как полные (HITS). Вы НЕ ДОЛЖНЫ использовать эту опцию если у Вас
# есть подчиненые кэши.
#
# ВНИМАНИЕ: Установка в этой опции размера меньше, чем размер сообщения Squid
# об ошибке приведет к бесконечному циклу и падению Squid-а. Удостоверьтесь, что
# наименьшее ненулевое значение, которое Вы используете, больше, чем максимальный размер
# заголовка + размер самой большой Вашей страницы с сообщением об ошибке.
#
# Если Вы установили значение "none" (по умолчанию), то ограничения не будет.
#
# Формат:
#	reply_body_max_size SIZE UNITS [acl ...]
# Например:
#	reply_body_max_size 10 MB
#
# Установки по умолчанию:
# none
#
#
# NETWORK OPTIONS (СЕТЕВЫЕ ОПЦИИ)
# -----------------------------------------------------------------------------
#
# TAG: http_port
# Применение:	port [options]
#		hostname:port [options]
#		1.2.3.4:port [options]
#
# Порт, на котором Squid будет слушать HTTP-запросы клиентов. Вы можете указать несколько
# портов. Существует 3 формы указаний: только порт, "hostname" + порт, и IP-адрес + порт.
# Если Вы указываете "hostname" или IP-адрес, Squid "биндит" (связывает) сокет с указанным
# адресом. Это заменяет старую опцию "tcp_incoming_address". Скорее всего у Вас нет
# необходимости в биндинге, т.о. Вы можете использовать только номер порта.
#
# Если Вы запускаете Squid в режиме "accelerator"-а, то возможно Вы захотите слушать
# и/или 80й порт (вместо/вместе стандартного).
#
# Опция командной строки "-a" может быть использована для указания дополнительных портов,
# на которых Squid будет слушать запросы. Эти порты будут обычными прокси-портами
# без опций.
#
# Вы можете указать несколько сокетов в нескольких строках.
#
#	Опции:
#
#	intercept
#	Поддержка перехвата исходящих запросов на IP-Layer без учета настроек браузера.
#	Примечание: Отключает аутентификацию и IPv6 на порту.
#
#	tproxy
#	Поддержка Linux TPROXY для подмены исходящих соединений используя клиентский
#	IP-адрес.
#	ВНИМАНИЕ: Отключает аутентификацию и, возможно, IPv6 на порту.
#
#	accel
#	Режим "accelerator"-а. Требует минимум одно из "vhost/vport/defaultsite".
#
#	allow-direct
#	Позволяет прямой "forwarding" в режиме "accelerator"-а. Обычно
#	"accelerated"-запросы запрещают прямой форвард как при использовании опции
#	"never_direct".
#
#	defaultsite=domainname
#	Что использовать в качестве "Host: header", если в запросе он отсутствует.
#	Определяет какое доменное имя (не оригинальный сервер) используется акселератором
#	по умолчанию.
#	Предполагает использование "accel".
#
#	vhost
#	Режим акселератора, использующий "Host header" для поддержки виртуального домена.
#	Предполагает использование "accel".
#
#	vport
#	Акселератор с IP-адресом, основанным на поддержке виртуального хоста.
#	Предполагает использование "accel".
#
#	vport=NN
#	То же что и выше, но использует вместо "http_port" указанный номер порта.
#	Предполагает использование "accel".
#
#	protocol=
#	Протокол реконструкции акселерированных запросов. По умолчанию - http.
#
#	ignore-cc
#	Игнорирует запросы заголовков "Cache-Control".
#	Внимание: Эта опция нарушает HTTP-спецификации, если используется вне режима
#	"accelerator".
#
#	connection-auth[=on|off]
#	Использование "connection-auth=off" говорит Squid-у не допускать форварда
#	аутентификационных соединений Microsoft (NTLM, Negotiate и Kerberos)
#
# disable-pmtu-discovery=
# Использование Path-MTU discovery:
#	off		Позволить ОС решать что делать (по умолчанию).
#	transparent	Отключить PMTU discovery когда включена поддержка прозрачности
#			(transparent).
#	always		Всегда отключать PMTU discovery.
#
# Во многих настройках прозрачных перехватывающих прокси "Path-MTU discovery"
# может не работать с трафиком в сторону клиентов. Это случай, когда устройства перехвата
# не полностью отслеживают соединения, и не могут форвардить кэш-серверу ICMP-сообщения,
# нуждающиеся в фрагментации. Если Вы используете такие настройки, и знаете, что
# некоторые клиенты временами удерживают (hang), либо никогда не завершают запросы,
# установите опцию "disable-pmtu-discovery" в "transparent".
#
#	ssl-bump
#	Перехватывает каждый CONNECT-запрос, совпадающий с ACL "ssl_bump", устанавливает
#	защищенное соединение между клиентом и сервером, расшифровывает HTTP-сообщения
#	во время их прохождения через Squid, и считает их расшифрованными
#	HTTP-сообщениями, становясь "man-in-the-middle".
#
#	Когда эта опция включена, становятся доступными дополнительные опции для указания
#	SSL-связанных настроек клиентского подключения: "cert", "key", "version",
#	"cipher", "options", "clientca", "cafile", "capath", "crlfile", "dhparams",
#	"sslflags" и "sslcontext". См. директивы "https_port".
#
#	"ssl_bump" опция требуется для полной поддержки возможностей "SslBump".
#
#	name=
#	Определяет внутреннее имя порта. По умолчанию установлено согласно параметрам
#	тэгов портов ("port" или "addr:port").
#
#	tcpkeepalive[=idle,interval,timeout]
#	Включить TCP-keepalive "зонды" (probes) для простаивающих соединений.
#	Параметры указываются в секундах.
#	"idle" - время инициализации, перед тем как TCP начнет "зондировать" соединение,
#	"interval" - частота "зондирования", и "timeout" - время, по прошествии которого
#	произойдет отказ от соединения.
#
#	Если Вы запускаете Squid на компьютере с внутренним и внешним интерфейсами,
#	то мы рекомендуем Вам указать внутренний "адрес:порт" в "http_port".
#	Таким образом, Squid будет виден только по внутреннему адресу.
#
# Squid обычно слушает порт 3128
http_port 3128
#
#
#  TAG: https_port
# Примечание: Доступно только если Squid скомпилирован с опцией --enable-ssl
#
# Использование: [ip:]port cert=certificate.pem [key=key.pem] [options...]
#
# Адрес сокета на котором Squid будет слушать HTTPS-запросы клиентов.
#
# В действительности это полезно только в тех ситуациях, когда Вы запускаете Squid
# в режиме акселератора, и хотите сделать так, чтобы SSL работал на уровне акселератора.
#
# Вы можете указать несколько адресов сокетов в нескольких строках,
# где каждая строка имеет свой собственный SSL-сертификат и/или опции.
#
#
# Опции:
#
#	accel
#	Режим "accelerator"-а. Требует минимум одно из "defaultsite/vhost".
#
#	defaultsite=domainname
#	Имя HTTPS-сайта, представленного на этом порту. Используется для "accel".
#	Предполагает использование "accel".
#
#	vhost
#	Режим акселератора, использующий "Host header" для поддержки виртуального домена.
#	Требуется шаблон сертификата или иной сертификат, действительный более чем для
#	одного домена.
#	Предполагает использование "accel".
#
#	protocol=
#	Протокол реконструкции акселерированных запросов. По умолчанию - "https".
#
#	cert=
#	Путь к SSL-сертификату (PEM формат).
#
#	key=
#	Путь к приватному ключевому файлу SSL (PEM формат). Если не указан, то
#	предполагается, что файл сертификата содержит и сертификат, и ключевой файл.
#
#	version=
#	Поддерживаемые версии SSL/TLS
#		1	automatic (по умолчанию)  	Автоматически
#		2	SSLv2 only			Только SSLv2
#		3	SSLv3 only			Только SSLv3
#		4	TLSv1 only			Только TLSv1
#
#	cipher=
#	Список поддерживаемых шифров, разделенных двоеточием.
#
#	options=
#	Различные опции SSL-движка. Самые важные из них:
#		NO_SSLv2	Запрещает использовать SSLv2
#		NO_SSLv3	Запрещает использовать SSLv3
#		NO_TLSv1	Запрещает использовать TLSv1
#		SINGLE_DH_USE	 Всегда создает новый ключ, если использует обмен
#				 временными/эфемерными DH-ключами.
#
#	Для изучения полного списка опций SSL см. документацию "src/ssl_support.c"
#	или "OpenSSLSSL_CTX_set_options".
#
# [z_ЛИРИКА: Что такое СА. http://ru.wikipedia.org/wiki/Центр_сертификации ]
#
#	clientca=
#	Файл, содержащий список CA для использования при запросе клиентского сертификата.
#
#	cafile=
#	Файл, содержащий дополнительные CA-сертификаты для верификации сертификатов
#	клиента. Если отключить эту опцию, то будет использоваться "clientca".
#
#	capath=
#	Каталог, содержащий дополнительные CA-сертификаты и списки CRL для верификации
#	сертификатов клиента.
#
#	crlfile=
#	Файл дополнительных CRL-списков для верификации сертификатов клиента.
#	В дополнение к CRL, хранящимся в "capath".
#	Предполагает использование флага VERIFY_CRL (ниже).
#
#	dhparams=
#	Файл, содержащий DH-параметры, для обмена временными/эфемерными DH-ключами.
#
#	sslflags=
#	Различные флаги, модифицирующие использование SSL:
#	DELAYED_AUTH
#		Не запрашивать клиентский сертификат немедленно, но ожидать до тех пор,
#		пока он не потребуется обработке ACL (пока не осуществлено).
#	NO_DEFAULT_CA
#		Не использовать списки CA по умолчанию, встроенные в OpenSSL.
#	NO_SESSION_REUSE
#		Не разрешать повторное использование сессии. Каждое соединение
#		будет результатом новой SSL-сессии.
#	VERIFY_CRL
#		Проверять CRL-списки когда клиентские сертификаты приняты.
#	VERIFY_CRL_ALL
#		Проверять CRL-списки для всех сертификатов в цепочке клиентского
#		сертификата.
#
#	sslcontext=
#	ID контекстный идентификатор SSL-сессии.
#
#	vport
#	Акселератор с IP-адресом, основанным на поддержке виртуального хоста.
#	Предполагает использование "accel".
#
#	vport=NN
#	То же что и выше, но использует вместо "http_port" указанный номер порта.
#	Предполагает использование "accel".
#
#	name=
#	Определяет внутреннее имя порта. По умолчанию следует определению
#	в опциях порта ("port" или "addr:port").
#
# Установки по умолчанию:
# none
#
#
#  TAG: tcp_outgoing_tos
#
# Позволяет Вам выбрать значение "TOS/Diffserv" для маркировки исходящих соединений,
# созданных на основе имени пользователя или исходящего адреса, сделавшего запрос.
#
# tcp_outgoing_tos ds-field [!]aclname ...
#
# Пример, в котором ACL "normal_service_net" использует значение TOS равное 0x00
# и ACL "good_service_net" использует значение 0x20
#	acl normal_service_net src 10.0.0.0/24
#	acl good_service_net src 10.0.1.0/24
#	tcp_outgoing_tos 0x00 normal_service_net
#	tcp_outgoing_tos 0x20 good_service_net
#
# Значения TOS/DSCP имеют только локальное значение, т.о. вы должны знать, что указываете
# в ACL. См. RFC2474, RFC2475 и RFC3260.
#
# Значение TOS/DSCP байтов должно быть октетом в диапазоне 0-255, или "default",
# для использования значения по умолчанию, установленного для вашего хоста.
# Заметьте, что на практике, чаще всего, используются значения кратные 4м - два правых бита,
# которые были предопределены для использования ECN (см. RFC 3168 section 23.1).
# [z_ЛИРИКА: Explicit Congestion Notification.
# http://ru.wikipedia.org/wiki/Explicit_Congestion_Notification ]
#
# Обработка происходит в указанном порядке, и останавливается на первой, полностью
# совпадающей, строке.
#
# Примечание: Использование этого тэга с применением клиентозависимых ACL несовместимо
# с использованием "persistent"-соединений со стороны сервера.
# Для обеспечения правильных результатов при использовании этого тэга в таких
# конфигурациях лучше отключить опцию "server_persisten_connections".
# [z_ЛИРИКА: HTTP persistent connection.
# http://en.wikipedia.org/wiki/HTTP_persistent_connection ]
#
# Установки по умолчанию:
# none
#
#  TAG: clientside_tos
# Позволяет выбрать значение "TOS/Diffserv" для пометки (to mark) соединения со стороны
# клиента, основанное на имени пользователя или адресе источника запроса.
#
# Установки по умолчанию:
# none
#
#  TAG: qos_flows
# Примечание: Доступно только если Squid скомпилирован с опцией --enable-zph-qos
#
# Позволяет выбрать значение "TOS/DSCP" для пометки (to mark) исходящего соединения,
# основанного на источнике ответа.
#
# Значения "TOS/DSCP" имеют только локальное значение, т.о. вы должны знать
# что указываете в ACL. См. RFC2474, RFC2475 и RFC3260.
#
# Значение "TOS/DSCP" байтов должно быть октетом в диапазоне 0x00-0xFF. Заметьте, что
# на практике чаще всего используются значения до 0x3F - два старших бита,
# которые были предопределены для использования ECN (см. RFC 3168 section 23.1).
#
# Этот тэг настраивается установкой источника TOS-значения:
#	local-hit=0xFF		Значение, отмечающее попадания в местный кэш.
#	sibling-hit=0xFF 	Значение, отмечающее попадания из "sibling peers".
#	parent-hit=0xFF		Значение, отмечающее попадания из "parent peers".
#
# Примечание: Функция "miss" на данный момент возможна только в Linux.
#
# Что бы нижеследующие параметры работали правильно, Вам, возможно, необходимо пропатчить
# Ваше ядро Linux ZPH патчем, сохраняющим TOS.
# Патч для ядра можно скачать с http://zph.bratcheda.org
#
#	disable-preserve-miss
#	По умолчанию существующее значение TOS-ответа удаленного сервера будет
#	сохранено и замаскировано "miss"-меткой. Эта опция отключает эту функцию.
#
#	miss-mask=0xFF
#	Позволяет маскировать ("to mask") определенные биты в TOS, полученные от
#	удаленного сервера, перед копированием значения в TOS, отсылаемый клиентам.
#	Установки по умолчанию: 0xFF (TOS от сервера не изменен).
#
# Установки по умолчанию:
# none
#
#  TAG: tcp_outgoing_address
# Позволяет Вам маппировать запросы на различные исходящие IP-адреса, основываясь
# на имени или "source"-адресе пользователя, сделавшего запрос.
#	tcp_outgoing_address ipaddr [[!]aclname] ...
#
# Пример, где запросы:
#	от 10.0.0.0/24 будут отфорваржены с исходящим адресом 10.1.0.1,
#	от 10.0.2.0/24 будут отфорваржены с исходящим адресом 10.1.0.2,
#	и остальные будут отфорваржены с исходящим адресом 10.1.0.3.
#
#	acl normal_service_net src 10.0.0.0/24
#	acl good_service_net src 10.0.2.0/24
#	tcp_outgoing_address 10.1.0.1 normal_service_net
#	tcp_outgoing_address 10.1.0.2 good_service_net
#	tcp_outgoing_address 10.1.0.3
#
# Обработка происходит в указанном порядке, и останавливается на первой, полностью
# совпадающей, строке.
#
# Примечание: Использование этого тэга с применением клиентозависимых ACL несовместимо
# с использованием "persistent"-соединений со стороны сервера.
# Для обеспечения правильных результатов при использовании этого тэга в таких
# конфигурациях лучше отключить опцию "server_persisten_connections".
#
#
#        IPv6 Magic (Магия IPv6):
#
# Squid построен с возможностью бриджинга IPv4 и IPv6. "tcp_outgoing_address", как
# показано выше, нарушает этот бриджинг, заворачивая весь исходящий трафик через
# определенные IPv4, которые могут быть на неверной стороне границы IPv4/IPv6.
#
# Для работы с "tcp_outgoing_address" и сохранения преимуществ бриджинга
# необходимы дополнительные ACL, использование которых обеспечит запрет пропуска
# или принудительного заворота IPv6-связанного трафика через IPv4-интерфейс.
#
#	acl to_ipv6 dst ipv6
#	tcp_outgoing_address 2002::c001 good_service_net to_ipv6
#	tcp_outgoing_address 10.1.0.2 good_service_net !to_ipv6
#
#	tcp_outgoing_address 2002::beef normal_service_net to_ipv6
#	tcp_outgoing_address 10.1.0.1 normal_service_net !to_ipv6
#
#	tcp_outgoing_address 2002::1 to_ipv6
#	tcp_outgoing_address 10.1.0.3 !to_ipv6
#
# Внимание:
# "dst ipv6" основывает свой выбор предполагая "DIRECT access" (прямой доступ). Если пиры
# используют "peername" ACL - необходимо выбрать исходящий адрес, который можно связать
# с пиром.
#
# "dst ipv6" является медленным [slow] ACL. Он будет работать здесь только если "dst"
# используется ранее в "http_access"-правилах для нахождения IP-адреса назначения.
# Для этого необходима некоторая магия:
#	http_access allow to_ipv6 !all
# (подразумевается разрешение IPv6, но не отовсюду ;)
#
# Установки по умолчанию:
# none
#
#
# SSL OPTIONS (ОПЦИИ SSL)
# -----------------------------------------------------------------------------
#
# TAG: ssl_unclean_shutdown
# Примечание: Доступно только если Squid скомпилирован с опцией --enable-ssl
#
# Некоторые браузеры (особенно MSIE) имеют проблемы с завершением сессий SSL.
#
# Установки по умолчанию:
# ssl_unclean_shutdown off
#
#  TAG: ssl_engine
# Примечание: Доступно только если Squid скомпилирован с опцией --enable-ssl
#
# Для использования OpenSSL-движка. Например, если Вы хотите использовать хардварное
# ускорение SSL - необходимо установить эту опцию.
#
# Установки по умолчанию:
# none
#
#  TAG: sslproxy_client_certificate
# Примечание: Доступно только если Squid скомпилирован с опцией --enable-ssl
#
# SSL-сертификат клиента, используемый при проксировании URL-ов "https://"-типа.
#
# Установки по умолчанию:
# none
#
#  TAG: sslproxy_client_key
# Примечание: Доступно только если Squid скомпилирован с опцией --enable-ssl
#
# SSL-ключ клиента, используемый при проксировании URL-ов "https://"-типа.
#
# Установки по умолчанию:
# none
#
#  TAG: sslproxy_version
# Примечание: Доступно только если Squid скомпилирован с опцией --enable-ssl
#
# Версия SSL, используемая при проксировании URL-ов "https://"-типа.
#
# Установки по умолчанию:
# sslproxy_version 1
#
#  TAG: sslproxy_options
# Примечание: Доступно только если Squid скомпилирован с опцией --enable-ssl
#
# Опции SSL-движка, используемые при проксировании URL-ов "https://"-типа.
#
# Наиболее важными являются:
#	NO_SSLv2		Запрет использования SSLv2
#	NO_SSLv3		Запрет использования SSLv3
#	NO_TLSv1		Запрет использования TLSv1
#	SINGLE_DH_USE	Всегда создавать новый ключ, когда используется
#			обмен временными/эфемерными DH-ключами
#
# Эти опции изменяются в зависимости от используемого SSL-движка.
# См. документацию "OpenSSL SSL_CTX_set_options" для поиска полного списка возможных
# опций.
#
# Установки по умолчанию:
# none
#
#  TAG: sslproxy_cipher
# Примечание: Доступно только если Squid скомпилирован с опцией --enable-ssl
#
# Список разделенных двоеточием, поддерживаемых SSL-шифров, используемых при
# проксировании URL-ов "https://"-типа.
#
# Установки по умолчанию:
# none
#
#  TAG: sslproxy_cafile
# Примечание: Доступно только если Squid скомпилирован с опцией --enable-ssl.
#
# Файл, содержащий CA сертификаты, для проверки сертификатов сервера
# при проксировании URL-ов "https://"-типа.
#
# Установки по умолчанию:
# none
#
#  TAG: sslproxy_capath
# Примечание: Доступно только если Squid скомпилирован с опцией --enable-ssl
#
# Каталог, содержащий CA сертификаты, используемые для проверки сертификатов
# серверов при проксировании URL-ов "https://"-типа.
#
# Установки по умолчанию:
# none
#
#  TAG: ssl_bump
# Примечание: Доступно только если Squid скомпилирован с опцией --enable-ssl
#
# Этот ACL контролирует, какие CONNECT-запросы к "http_port", отмеченные флагом "sslBump",
# действительно были перехвачены ("bumped"). См. флаг "sslBump" в опциях "http_port" для
# более подробной информации о расшифровке проксированных SSL-соединений.
#
# По умолчанию запросы не перехватываются.
#
# См. http_port sslBump.
#
# Поддерживает только быстрые [fast] типы acl.
# См. http://wiki.squid-cache.org/SquidFaq/SquidAcl
#
# Пример:
# Перехватывать все запросы, кроме тех, которые идут от localhost
# или к webax.com или example.com
#	acl localhost src 127.0.0.1/32
#	acl broken_sites dstdomain .webax.com
#	acl broken_sites dstdomain .example.com
#	ssl_bump deny localhost
#	ssl_bump deny broken_sites
#	ssl_bump allow all
# Установки по умолчанию:
# none
#
#  TAG: sslproxy_flags
# Примечание: Доступно только если Squid скомпилирован с опцией --enable-ssl
#
# Различные флаги, модифицирующие использование SSL при проксировании URL-ов
# "https://"-типа:
#	DONT_VERIFY_PEER 	Принимать сертификаты, даже если они не прошли проверку.
#				Для более гибкого управления см. "sslproxy_cert_error".
#	NO_DEFAULT_CA		Не использовать дефолтный список CA, встроенный в OpenSSL.
#
# Установки по умолчанию:
# none
#
#  TAG: sslproxy_cert_error
# Примечание: Доступно только если Squid скомпилирован с опцией --enable-ssl
#
# Используйте этот ACL для обхода ошибки проверки сертификатов сервером.
#
# Следующий пример позволяет обойти все ошибки проверки в общении с серверами,
# расположенными в сети 172.16.0.0/16. Все остальные ошибки проверки приведут к ошибке
# "ERR_SECURE_CONNECT_FAIL".
#	acl BrokenServersAtTrustedIP dst 172.16.0.0/16
#	sslproxy_cert_error allow BrokenServersAtTrustedIP
#	sslproxy_cert_error deny all
#
# Поддерживает только быстрые [fast] типы acl.
# См. http://wiki.squid-cache.org/SquidFaq/SquidAcl
# Использование медленных типов может привести к падению сервера!
#
# Без этой опции любая ошибка проверки сертификатов сервера прекратит обмен данными.
# Обход ошибки проверки опасен, потому что ошибка обычно означает, что сервер не может
# быть надежным, и соединение может быть небезопасно.
#
# См. sslproxy_flags и DONT_VERIFY_PEER.
#
#	Default setting:	sslproxy_cert_error deny all
#
# Установки по умолчанию:
# none
#
#  TAG: sslpassword_program
# Примечание: Доступно только если Squid скомпилирован с опцией --enable-ssl
#
# Определяет программу, используемую для ввода ключевых фраз SSL при использовании
# зашифрованных ключей SSL-сертификатов. Если не определено, ключи должны быть
# либо в открытом виде, либо необходимо запускать Squid с ключом -N, чтобы разрешить
# ему запрос парольной фразы ("passphrase") в интерактивном режиме.
#
# Имя файла ключа задается в качестве аргумента программы, позволяющей выбрать правильный
# пароль, если у вас есть несколько зашифрованных ключей.
#
# Установки по умолчанию:
# none
#
#
# OPTIONS WHICH AFFECT THE NEIGHBOR SELECTION ALGORITHM
# (ОПЦИИ, ВЛИЯЮЩИЕ НА АЛГОРИТМ ВЫБОРА "СОСЕДЕЙ")
# -----------------------------------------------------------------------------
#
#  TAG: cache_peer
# Для указания других кэшей в иерархии. Использует формат:
#	cache_peer hostname type http-port icp-port [options]
#
# Пример:
#						прокси	icp
#		   имя хоста		тип	порт	порт	опции
#		   --------------------	-------	-----	-----	----------------
#	cache_peer parent.foo.net 	parent	3128	3130	default
#	cache_peer sib1.foo.net		sibling	3128	3130	proxy-only
#	cache_peer sib2.foo.net		sibling	3128	3130	proxy-only
#	cache_peer example.com		parent	80	0	no-query default
#	cache_peer cdn.example.com	sibling	3128	0
#
#	тип:		Либо "parent", либо "sibling", либо "multicast".
#	proxy-port:	Номер порта, на котором пир принимает HTTP-запросы.
#			Для других Squid-прокси обычно 3128.
#			Для веб-серверов обычно 80.
#	icp-port:	Используется для запроса соседских кэшей об объектах.
#			Установить в 0, если peer не поддерживает ICP или HTCP.
#			Детали см. ниже в опциях ICP и HTCP.
#
#	==== ICP OPTIONS (ОПЦИИ Internet Cache Protocol) ====
# [z_ЛИРИКА: Internet Cache Protocol.
# http://etutorials.org/Server+Administration/Squid.+The+definitive+guide/Chapter+10.+Talking+to+Other+Squids/10.6+Internet+Cache+Protocol/ ]
#
# При использовании этих опций Вы ДОЛЖНЫ явно установить опции "icp_port" и "icp_access".
# Установки по умолчанию запрещают "peer"-трафик использующий ICP.
#
#	no-query
#	Запрещает ICP-запросы к указанному соседу.
#
#	multicast-responder
#	Определяет проименованный (указанный) пир членом группы "multicast".
#	ICP-запросы не будут посылаться к нему напрямую, но ICP-ответы от него
#	будут приниматься.
#
#	closest-only
#	Определяет, что при ответах "ICP_OP_MISS", мы будем переправлять только ответы
#	"CLOSEST_PARENT_MISS" и никогда "FIRST_PARENT_MISS".
#
#	background-ping
#	Для нечастой отправки этому соседу только ICP-запросов.
#	Используется для хранения обновления соседского "round trip time",
#	и обычно используется в сочетании с опцией "weighted-round-robin".
# [z_ЛИРИКА: Round-trip delay time. http://en.wikipedia.org/wiki/Round-trip_delay_time ]
#
#
#	==== HTCP OPTIONS ====
#
# При использовании этих опций Вы ДОЛЖНЫ явно установить опции "htcp_port"
# и "htcp_access". Установки по умолчанию запрещают "peer"-трафик, использующий HTCP.
#
#	htcp
#	Отсылает "соседу" HTCP-запросы вместо ICP.
#	Возможно Вы также захотите установить "icp-port" равный 4827 вместо 3130.
#
#	htcp-oldsquid
#	Отсылает старым версиям Squid-а HTCP.
#
#	htcp-no-clr
#	Отсылает "соседу" HTCP, но без посылки каких-либо CLR-запросов.
#	Не может быть использовано с "htcp-only-clr".
#
#	htcp-only-clr
#	Отсылает "соседу" HTCP, НО ТОЛЬКО CLR-запросы.
#	Не может быть использовано с "htcp-no-clr".
#
#	htcp-no-purge-clr
#	Отсылает "соседу" HTCP включая CLR-ы, но только тогда,
#	когда они не являются результатом PURGE-запросов.
#
#===^===
#	htcp-forward-clr
#	Форвард "peer"-у любых HTCP CLR-запросов, которые получил этот прокси.
#	Forward any HTCP CLR requests this proxy receives to the peer.
#=======
#
#
#	==== PEER SELECTION METHODS ====
#
# По умолчанию выбор "peer"-ов осуществляется методом ICP, где в качестве источника
# будет использован первый ответивший "peer". Эти опции могут быть использованы
# для лучшей балансировки нагрузки.
#
#	default
#	Это "родительский" кэш, который может быть использован в качестве
#	"последней инстанции", если пир невозможно обнаружить никакими методами выбора.
#	Если указано более одного, будет использоваться только первый.
#
#	round-robin
#	Балансировка нагрузки родительских кэшей, которые должны быть использованы
#	в циклическом ("round-robin") стиле в отсутствие любых ICP-запросов.
#	Для добавления смещения можно использовать weight=N.
#
#	weighted-round-robin
#	Балансировка нагрузки родительских кэшей, которые должны быть использованы
#	в циклическом стиле с частотой каждого из родителей основанной "round trip time".
#	Ближние "parents" используются чаще. Обычно используется для родителей
#	с включенным "background-ping"-ом. Для добавления смещения можно использовать
#	"weight=N".
#
#	carp
#	Балансировка нагрузки родительских кэшей, которые будут использоваться как
#	CARP-массив. Запросы будут распределены между "родителями", основываясь на
#	хэш-функции балансировки нагрузки CARP, исходя из их "веса" ("weight").
#
#	userhash
#	Балансировка нагрузки родительских кэшей, основанная на "proxy_auth" клиента
#	или "ident"-имени пользователя.
#
#	sourcehash
#	Балансировка нагрузки родительских кэшей, основанная на IP-адресе клиента.
#
#	multicast-siblings
#	Используется только для "cache"-пиров "multicast"-типа. ВСЕ члены этой группы
#	многоадресной рассылки имеют не "parent", а "sibling"-отношения.
#	Это оптимизация, позволяющая избежать бесполезных "multicast"-запросов в
#	"multicast"-группе, если запрашиваемый объект, так или иначе, должен быть закачан
#	только из "родительского" кэша. Полезно, например, при настройке избыточного
#	пула Squid-прокси, которые являются членами той же группы многоадресной рассылки.
# [z_ЛИРИКА:
# В оригинальном squid.conf.documented для FreeBSD отсутствует строка, что не позволяет
# адекватно перевести часть описания этой опции. Поправка взята из squid.conf
# SQUID 2.7.STABLE7. Ниже полный оригинал этого предложения:
# "This is an optimization that avoids useless multicast queries to a multicast group
# when the requested object would be fetched only from a "parent" cache, anyway".]
#
#
#	==== PEER SELECTION OPTIONS ====
#
#	weight=N
#	Используется для влияния на выбор пира в работе любых "весовых" механизмов
#	выбора пира. Вес ("weight") должен быть целым числом. По умолчанию 1. БОльшие
#	числа более предпочтительны. Эта опция не влияет на выбор "parent"-а,
#	если не используется "peering"-протокол.
#
#	basetime=N
#	Определяет базовую сумму, вычетаемую из "round trip time" родителей.
#	Она вычитается до начала "весового" разделения, определяющего с какого
#	родительского кэша забирать данные. Если "round trip time" меньше, чем
#	"basetime", то оно устанавливается в минимальное значение.
#
#	ttl=N
#	Определяет "IP multicast TTL", используемый при отсылке ICP-пакетов на этот
#	адрес. Полезно только в случае отправки "multicast"-группе.
#	Поскольку мы не принимаем ICP-ответы от произвольных хостов, Вы должны
#	сконфигурировать остальных членов группы как пиров, используя опцию
#	"multicast-responder".
#
#	no-delay
#	Предотвращать доступ к этому соседу из-за влияния "delay pools".
#
#	digest-url=URL
#	Указывает Squid-у забрать "cache digest" (если "digest" включен) для этого хоста
#	с указанного URL, вместо его обычного расположения в Squid-е.
#
#
#	==== ACCELERATOR / REVERSE-PROXY OPTIONS ====
#
#	originserver
#	Является причиной того, что этот "родитель" объявляет себя исходным сервером.
#	Предназначена для использования в установках "accelerator", когда "peer"
#	является веб-сервером.
#
#	forceddomain=name
#	Устанавливает Host-заголовки запросов, направленных к этому пиру.
#	Используется в режиме "accelerator", когда сервер ("peer") ожидает определенного
#	доменного имени, но клиенты могут запросить другие, т.е. "example.com" или
#	"www.example.com"
#
#	no-digest
#	Запрещает запросы "cache digest".
#
#	no-netdb-exchange
#	Запрещает запросы к ICMP RTT базе данных (NetDB).
#
#
#	==== AUTHENTICATION OPTIONS (ОПЦИИ АУТЕНТИФИКАЦИИ) ====
#
#	login=user:password
#	Используется, если это "персональный прокси/прокси рабочей группы", и если ваш
#	"parent" требует прокси-аутентификации.
#	Примечание: Строка может содержать URL "esc"-символы (например, %20 - пробел).
#	Это также подразумевает, что символ "%" должен писаться как "%%".
#
#	login=PROXYPASS
#	Отправить детали "login"-а, полученные этим "peer"-ом от клиента.
#	Аутентификация не требуется и не меняется.
#	===^===
#	Примечание: Пройдет любую форму аутентификации, но только "Basic"-аутентификация
#	будет работать через прокси, если одновременно (не?) будет использоваться
#	опция "connection-auth".
#	Note: This will pass any form of authentication but only Basic auth will work
#	through a proxy unless the connection-auth options are also used.
#	=======
#
#	login=PASS
#	Отправить детали "login"-а, полученные этим "peer"-ом от клиента.
#	Эта опция не требует аутентификации.
#	Если отсутствует аутентификационный заголовок, предоставленный клиентом для
#	передачи, но имя пользователя и пароль доступны либо из прокси-аутентификации,
#	либо как тэги "user=" и "password=" - результат работы внешних ACL, то они могут
#	быть посланы взамен (отсутствующих).
#
#	Примечание: Чтобы объединить эту опцию с "proxy_auth" оба прокси должны
#	иметь одинаковую базу данных пользователей. Так как HTTP допускает только
#	одну авторизацию (одну для прокси, одну для оригинального сервера). Так же
#	будьте предупреждены, что эта опция открывает "peer"-ам прокси-пароли Ваших
#	пользователей. ИСПОЛЬЗОВАТЬ ОСТОРОЖНО!
#
#	login=*:password
#	Отправить "username" вышестоящему кэшу, но с фиксированным паролем.
#	Подразумевается использование, когда пир находится в другом административном
#	домене, но, тем не менее, нуждается в идентификации каждого пользователя. В поле
#	"звездочка" можно предоставлять необязательную дополнительную информацию, которая
#	добавляется к имени пользователя. Это можно использовать для идентификации
#	этого прокси "peer"-ом, схоже с опцией "login=username:password" выше.
#
#	connection-auth=on|off
#	Сообщает Squid-у, поддерживает или нет этот "peer" Microsoft-ориентированные
#	подключения для аутентификации, и любые полученные запросы авторизации подобного
#	вида должны быть проигнорированы. По умолчанию "auto", для автоматического
#	определения статуса "peer"-а.
#
#
#	==== SSL / HTTPS / TLS OPTIONS (ОПЦИИ SSL/HTTPS/TLS) ====
#
#	ssl
#	Шифрует подключения к этому прокси с помощью SSL/TLS.
#
#	sslcert=/path/to/ssl/certificate
#	Указывает путь к SSL-сертификату клиента, для использования при подключении
#	к этому "peer"-у.
#
#	sslkey=/path/to/ssl/key
#	Указывает путь к приватному SSL-ключу, соответствующий указанному выше "sslcert".
#	Если "sslkey" не определен, то "sslcert" считается ссылкой на объединенный
#	файл, содержащий и ключ, и сертификат.
#
#	sslversion=1|2|3|4
#	Версия SSL, используемая при соединении с этим "peer"-ом:
#		1	автоматически (по умолчанию)
#		2	только SSL v2
#		3	только SSL v3
#		4	только TLS v1
#
#	sslcipher=...
#	Список валидных SSL-шифров, для использования при подключении к этому "peer"-у.
#
#	ssloptions=...
#	Определяет различные опции SSL-движка:
#		NO_SSLv2	Запрещает использовать SSLv2
#		NO_SSLv3	Запрещает использовать SSLv3
#		NO_TLSv1	Запрещает использовать TLSv1
#	Для получения более подробного списка см. "src/ssl_support.c"
#	или документацию по OpenSSL
#
#	sslcafile=...
#	Файл, содержащий дополнительные CA-сертификаты, для использования при
#	проверке сертификатов "peer"-а.
#
#	sslcapath=...
#	Директория, содержащая дополнительные CA-сертификаты, для использования при
#	проверке сертификатов "peer"-а.
#
#	sslcrlfile=...
#	Список отозванных сертификатов, для использования при
#	проверке сертификатов "peer"-а.
#
#	sslflags=...
#	Определяет различные флаги, изменяющие реализацию SSL:
#		DONT_VERIFY_PEER
#			Принимать сертификаты, даже если они не прошли проверку.
#		NO_DEFAULT_CA
#			Не использовать дефолтный список CA, встроенный в OpenSSL.
#		DONT_VERIFY_DOMAIN
#			Не проверять сертификаты "peer"-ов, совпадающие с именем сервера.
#
#	ssldomain=
#	Имя "peer"-а, представленное в его сертификате. Используется для проверки
#	корректности сертификата, полученного от "peer"-а. Если не указано, то будет
#	использоваться hostname "peer"-а.
#
#	front-end-https
#	Включает заголовок "Front-End-Https: On", необходимый при использовании Squid
#	как SSL-фронтенда (интерфейса взаимодействия) для Microsoft OWA.
#	См. MS KB Q307347.
#	Если установлено в "auto", заголовок будет добавлен только если запрос
#	форвардится как URL "https://"-типа.
#
#
#
#	==== GENERAL OPTIONS (ОБЩИЕ ОПЦИИ) ====
#
#	connect-timeout=N
#	Определяет специфичный для "peer"-а таймаут соединения. См. "peer_connect_timeout".
#
#	connect-fail-limit=N
#	Сколько неудачных попыток соединения должно пройти перед пометкой "peer"-а
#	нерабочим. По умолчанию 10.
#
#	allow-miss
#	Отключить использование Squid-ом "only-if-cached" при перенаправлении запросов
#	братским кэшам. Эта функция в первую очередь полезна, когда братскими кэшами
#	используется "icp_hit_stale". Вы должны избегать наличия двустороннего "peer"-инга
#	с этой опцией, т.к. её широкое использование может привести к зацикливанию
#	("forwarding loops").
#	Например, запретить использование "peer"-ов в запросах от "peer"-ов,
#	запретив "cache_peer_access", если источником является "peer".
#
#	max-conn=N
#	Лимит количества подключений, которые Squid может открыть этому "peer"-у.
#	См. так же [z_ЛИРИКА: Окончание фразы в оригинале отсутствует]
#
#	name=xxx
#	Уникальное имя "peer"-а.
#	Требуется, если Вы имеете несколько "peer"-ов на разных портах одного хоста.
#	Это имя может быть использовано в "cache_peer_access" и схожих директивах
#	для идентификации "peer"-ов.
#	Может быть использовано для контроля исходящих соединений в ACL типа "peername".
#
#	no-tproxy
#	Не использовать поддержку "client-spoof TPROXY" для форварда запросов
#	к этому "peer"-у. Вместо этого использовать нормальный выбор адреса.
#
#	proxy-only
#	Определяет, что скачаные с "peer"-а объекты не будут сохранятся локально.
#
# Установки по умолчанию:
# none
#
#
#  TAG: cache_peer_domain
# Используйте для ограничения доменов, для которых будут посылаться запросы
# к соседним кэшам. Использование:
#	cache_peer_domain cache-host domain [domain ...]
#	cache_peer_domain cache-host !domain
#
# Например, определение
#	cache_peer_domain parent.foo.net     .edu
#
# обладает следующим эффектом: UDP-пакеты запроса посылаются "bigserver"-у только тогда,
# когда запрошенный объект существует в домене .edu. Размещение перед именем домена
# символа "!" означает, что у кэша будут запрашиваться объекты НЕ из этого домена.
#
# Примечание:
# Кэш-хосту можно передать любое количество доменов, в одной или нескольких строках.
# В случае передачи конкретному кэш-хосту нескольких доменов, применяется первый
# совпавший домен. Кэш-хосты, без доменных ограничений, принимают все запросы.
# Здесь нет значений по умолчанию.
# Существует также тэг "cache_peer_access" в секции ACL.
#
# Установки по умолчанию:
# none
#
#  TAG: cache_peer_access
# Похож на тэг "cache_peer_domain", но предоставляет большую гибокость за счет
# использования элементов ACL.
#	cache_peer_access cache-host allow|deny [!]aclname ...
# Синтаксис идентичен "http_access" и другим спискам элементов ACL. См. "http_access"
# ниже или Squid FAQ (http://wiki.squid-cache.org/SquidFaq/SquidAcl).
#
# Установки по умолчанию:
# none
#
#  TAG: neighbor_type_domain
# Использование:
#	neighbor_type_domain neighbor parent|sibling domain domain ...
# Теперь стало возможным изменять тип соседского прокси для указанных доменов.
# Вы можете рассматривать некоторые домены иначе, чем указанный по умолчанию в строке
# "cache_peer" тип соседа.
# Обычно это должно быть необходимо только для перечисления доменов, "neighbor"-тип
# которых должен определяться иначе, потому что "neighbor"-тип по умолчанию
# применяется для хостов ("hostnames"), которые не совпадают с перечисленными здесь
# доменами.
#
#Например:
#	cache_peer cache.foo.org parent 3128 3130
#	neighbor_type_domain cache.foo.org sibling .com .net
#	neighbor_type_domain cache.foo.org sibling .au .de
#
# Установки по умолчанию:
# none
#
#  TAG: dead_peer_timeout [в секундах]
# Определяет время ожидания до того как Squid объявит кэш-пир "мертвым". Если в течение
# этого времени нет полученных ICP-ответов, Squid объявит пир "мертвым" и не будет
# рассчитывать на получение дальнейших ICP-ответов. Однако Squid продолжит отправлять
# ICP-запросы, и пометит пир "живым" после получения первого последующего ответа.
#
# Этот таймаут также влияет на ожидание Squid-ом ICP-ответов от пиров. Если с момента
# получения последнего ICP-ответа прошло больше секунд, чем указано в "dead_peer",
# Squid не будет рассчитывать на получение ICP-ответа на следующий запрос. Таким образом,
# если ваше время между запросами больше, чем этот тайм-аут, Вы увидите много запросов
# отправленных напрямую (DIRECT) к оригинальным серверам, вместо (отправки) запросов к
# Вашим "parent"-ам.
#
# Установки по умолчанию:
# dead_peer_timeout 10 seconds
#
#  TAG: forward_max_tries
# Определяет, сколько различных путей перенаправления будет попробовать Squid, прежде чем
# сдаться. См. "forward_timeout".
#
# Установки по умолчанию:
# forward_max_tries 10
#
#  TAG: hierarchy_stoplist
# Список слов, которые, будучи найдены в URL, являются поводом для обработки объекта
# непосредственно этим кэшем. Другими словами, используйте этот тэг, чтобы не запрашивать
# у соседских кэшей определенные объекты. Вы можете использовать эту опцию несколько раз.
# Примечание: "never_direct" переопределяет эту опцию.
#
# Мы рекомендуем Вам использовать, по крайней мере, следующую строку.
hierarchy_stoplist cgi-bin ?
#
#
#
# MEMORY CACHE OPTIONS (ОПЦИИ ПАМЯТИ КЭША)
# -----------------------------------------------------------------------------
#  TAG: cache_mem [в байтах]
#
# ПРИМЕЧАНИЕ: ЭТОТ ПАРАМЕТР НЕ ОПРЕДЕЛЯЕТ МАКСИМАЛЬНЫЙ РАЗМЕР ПРОЦЕССА.
# ОН ТОЛЬКО УСТАНАВЛИВАЕТ ПРЕДЕЛ НА ТО, СКОЛЬКО ДОПОЛНИТЕЛЬНОЙ ПАМЯТИ SQUID БУДЕТ
# ИСПОЛЬЗОВАТЬ КАК ПАМЯТЬ ДЛЯ КЭШИРОВАНИЯ ОБЪЕКТОВ. SQUID ИСПОЛЬЗУЕТ ПАМЯТЬ И ДЛЯ
# ДРУГИХ ЦЕЛЕЙ. СМ. SQUID FAQ, СЕКЦИЯ 8.
#
#	"cache_mem" определяет идеальное количество памяти используемой для:
#		* In-Transit objects (транзитных объектов)
#		* Hot Objects ("горячих" объектов)
#		* Negative-Cached objects (негативно скэшированных объектов)
#
# Данные этих объектов хранятся в 4Кб блоках. Этот параметр определяет идеальный
# верхний предел общего размера (памяти), выделенного для 4Кб блоков. "In-Transit"
# объекты имеют наивысший приоритет.
#
# "In-transit"-объекты имеют преимущество перед другими. Когда для входящих данных
# необходимо дополнительное пространство, "negative-cached" и "hot"-объекты будут
# удалены ("released"). Другими словами, "negative-cached" и "hot"-объекты будут заполнять
# любое пространство, в котором не нуждаются "in-transit"-объекты.
#
# Если того потребуют обстоятельства, этот лимит будет превышен. А именно, если темп
# Ваших входящих запросов требует для хранения "in-transit"-объектов больше памяти,
# чем определено "cache_mem", Squid превысит этот лимит для удовлетворения новых
# запросов. Когда нагрузка снизится до пиковой отметки, блоки будут высвобождены.
# Впоследствии блоки будут использоваться для хранения "hot"-объектов.
#
# Установки по умолчанию:
# cache_mem 256 MB
#
#  TAG: maximum_object_size_in_memory [в байтах]
# К объектам большего размера чем этот, не будут применяться попытки сохранения в
# памяти кэша. Размер должен быть установлен достаточно большим, чтобы хранить часто
# запрашиваемые объекты в памяти, для повышения производительности, и в то же время
# достаточно низким, чтобы предотвратить накопление больших объектов в "cache_mem".
#
# Установки по умолчанию:
# maximum_object_size_in_memory 512 KB
#
#  TAG: memory_replacement_policy
# Параметры политики замены памяти определяют, какие объекты будут удалятся из памяти,
# когда она (память) потребуется.
# См. cache_replacement_policy
#
# Установки по умолчанию:
# memory_replacement_policy lru
#
#
# DISK CACHE OPTIONS (ОПЦИИ ДИСКОВОГО КЭША)
# -----------------------------------------------------------------------------
#
#  TAG: cache_replacement_policy
#
# Параметр политики замены кэша определяет объекты, которые "выселяются" (заменяются)
# когда требуется дисковое пространство.
#	lru:		Политика Squid, основанная на исходных списках.
#	heap GDSF:	Частота "дважды-жадного" размера ("Greedy-Dual Size Frequency")
#			см. ниже.
#	heap LFUDA:	Редко использовавшийся, с динамическим старением.
#	heap LRU:	Политика LRU, реализуемая при помощи "heap".
#
# [z_ЛИРИКА:
# lru (least recently used) - мало использовавшиеся в последнее время.
# См. Алгоритмы_кэширования http://ru.wikipedia.org/wiki/Алгоритмы_кэширования
# GDSF ("Greedy-Dual Size Frequency") - похоже на ошибку. В этом документе
# http://www.hpl.hp.com/techreports/1999/HPL-1999-69.html
# расшифровка аббревиатуры дана так:
# Greedy Dual-Size Frequency, т.е. "жадная частота двойного размера".]
#
# Применяется к любым строкам "cache_dir", перечисленным ниже.
#
# Политики LRU хранят объекты, на которые недавно ссылались.
#
# Политика "heap GDSF" оптимизирует коэффициент "объект-хит", сохраняя меньшие популярные
# объекты в кэше. Т.о. она имеет больше шансов получить хит. Этим достигается байтовый
# хит-рейт ниже, чем у LFUDA, так как он заменяет бОльшие (возможно, популярные) объекты.
#
# Политика "heap LFUDA" хранит популярные объекты в кэше независимо от их размера,
# и, т.о., оптимизирует байтовый хит-рейт за счет хит-рейта, поскольку один большой,
# популярный объект будет предотвращать кэширование многих меньших, чуть менее
# популярных объектов.
#
# Обе политики используют механизм динамического старения, который предотвращает
# загрязнение кэша, что, в противном случае, может произойти с частотными политиками
# замены.
#
# ПРИМЕЧАНИЕ: если используется политика замены LFUDA, Вы должны увеличить значение
# тэга "maximum_object_size" (см. выше), по умолчанию равное 4096 Кб, для увеличения
# потенциального прироста байтового хит-рейта в LFUDA.
#
# О GDSF и LFUDA политиках замены кэша см.
# http://www.hpl.hp.com/techreports/1999/HPL-1999-69.html
# и http://fog.hpl.external.hp.com/techreports/98/HPL-98-173.html.
#
# Установки по умолчанию:
# cache_replacement_policy lru
#
#  TAG: cache_dir
# Использование:
#	cache_dir Type Directory-Name Fs-specific-data [options]
#
# Вы можете указать несколько строк "cache_dir" для распределения кэша на различных
# партициях жесткого диска.
#
# Параметр "Type" определяет тип используемой файловой системы.
# По умолчанию встроен только тип "ufs". Для включения любой другой системы хранения
# см. опцию конфигурирования "-enable-storeio".
#
# "Directory"
# Директория верхнего уровня, где будут храниться своп-файлы кэша. Если Вы хотите
# использовать для кэширования весь диск, то это может быть "mount-point" директория.
# Директория должна существовать и иметь доступ на запись Squid-процессом.
# Squid НЕ создаст эту директорию за вас.
#
# Тип хранения "ufs":
#	"ufs" это старый, известный Squid-овый формат хранения, который был здесь всегда.
#	cache_dir ufs Directory-Name Mbytes L1 L2 [options]
#
# "Mbytes"
# Размер дискового пространства (MB) для использования под эту директорию. По умолчанию
# 100 Мб. Измените в соответствии со своей конфигурацией. НЕ указывайте здесь размер
# Вашего жесткого диска! Вместо этого, если Вы хотите, чтобы Squid использовал весь
# жесткий диск, вычтите 20% (от размера диска) и используйте полученное значение.
#
# "L1"
# Количество поддиректорий первого уровня, которые будут созданы в "Directory".
# По умолчанию 16.
#
# "L2"
# Количество поддиректорий второго уровня, которые будут созданы в каждой директории
# первого уровня. По умолчанию 256.
#
# Тип хранения "aufs":
# "aufs" использует похожий с "ufs" формат хранения, использующий POSIX-потоки для
# избежания блокирования основного процесса Squid во время дисковых операций
# записи/чтения. В Squid-е известно как "async-io".
#	cache_dir aufs Directory-Name Mbytes L1 L2 [options]
#
# См. описание аргументов, используемых в "ufs" (выше).
#
# Тип хранения "diskd":
# "diskd" использует похожий с "ufs" формат хранения, использующий раздельные процессы,
# для избежания блокирования основного процесса Squid во время дисковых операций
# записи/чтения.
#	cache_dir diskd Directory-Name Mbytes L1 L2 [options] [Q1=n] [Q2=n]
# См. описание аргументов, используемых в "ufs" (выше).
#
# "Q1" определяет количество I/O-запросов, оставшихся без ответа, по достижении
# которого Squid перестает открывать новые файлы. Если в очереди много сообщений, то
# Squid не будет открывать новые файлы. По умолчанию 64.
#
# "Q2" определяет количество сообщений, оставшихся без ответа, по достижении которого
# Squid начинает блокировку. Если в очереди много сообщений - Squid будет блокировать (их)
# до тех пор, пока не получит несколько ответов. По умолчанию 72.
#
# Когда Q1 < Q2 (по умолчанию), кэш директория оптимизирована для наименьшего времени
# ответа, за счет хит-рейта. Если Q1 > Q2, кэш директория оптимизирована для наивысшего
# хит-рейта, за счет увеличения времени ответа.
#
# Тип хранения "coss":
#
# Примечание: файловая система COSS в Squid-3 была сочтена слишком неустойчивой
# для использования в производстве и, таким образом, была удалена из этого релиза.
# Мы надеемся, что вскоре сделаем ее пригодной для использования.
#
# block-size=n
# Определяет "block size" для COSS "cache_dir". Squid использует номера файлов как
# номера блоков. Т.к. номера файлов ограничены 24мя битами, размер блока определяет
# максимальный размер COSS раздела. По умолчанию 512 байтов, что определяет
# максимальный размер "cache_dir" 512<<24, или 8 Гб. Заметьте, Вы не должны менять
# размер "coss"-блоков после того, как Squid записал несколько объектов в "cache_dir".
#
# Файловое хранилище COSS было изменено с версии 2.5. Теперь оно использует файл,
# именуемый "stripe", в именах директорий в конфигурации, и создается командой "squid -z".
#
# Общие опции:
#
# no-store
# новые объекты не должны быть сохранены в этой "cache_dir".
#
# max-size=n
# Определяет максимальный размер объекта, поддерживаемый этой директорией ("storedir").
# Используется для первоначального выбора директории хранения для выгрузки объекта.
# Примечание: Для оптимального использования лимитов "max-size" Вы должны расположить
# строки "cache_dir" начиная с наименьшего значения "max-size" и заканчивая строкой без
# указания "max-size".
#
# Примечание по COSS, "max-size" должно быть менее, чем COSS_MEMBUF_SZ, который можно
# изменить при компиляции опцией --with-coss-membuf-size=N.
#
# Раскомментируйте и скорректируйте следующую строку для добавления кэш-директории.
# cache_dir ufs /var/squid/cache 100 16 256
#
#  TAG: store_dir_select_algorithm
# Установите этот тэг в значение "round-robin", если нужна альтернатива.
# [z_ЛИРИКА: Описание тэга и алгоритмов выбора директории для кэширования.
# http://etutorials.org/Server+Administration/Squid.+The+definitive+guide/Chapter+7.+Disk+Cache+Basics/7.4+Allocating+Objects+to+Cache+Directories/]
#
# Установки по умолчанию:
# store_dir_select_algorithm least-load
#
#  TAG: max_open_disk_fds
# Во избежание затора во время дисковых операций записи/чтения, Squid может опционально
# обходить дисковый кэш, если количество открытых файловых дескрипторов превышает
# значение этого тэга.
# Значение "0" указывает на отсутствие ограничений.
#
# Установки по умолчанию:
# max_open_disk_fds 0
#
#  TAG: minimum_object_size [в байтах]
# Объекты меньше указанного размера НЕ БУДУТ сохранятся на диск.
# Значение указывается в килобайтах, и по умолчанию равно 0, что подразумевает отсутствие
# ограничений.
#
# Установки по умолчанию:
# minimum_object_size 0 KB
#
#  TAG: maximum_object_size [в байтах]
# Объекты больше указанного размера НЕ БУДУТ сохранятся на диск.
# Значение указывается в килобайтах, и по умолчанию равно 4MB. Если Вы желаете
# получить высокий байтовый "хит-рейт", возможно Вам придется увеличить это значение
# (один хит 32MB объекта считается за 3200 10KB хитов). Если Вы желаете увеличить
# скорость больше, чем хотите сохранить пропускную способность, Вы должны оставить
# это значение низким.
#
# ПРИМЕЧАНИЕ: если Вы используете политику замены LFUDA, Вы должны увеличить это
# значение для максимизации байтового "хит-рейта" в LFUDA! См. тэг "replacement_policy"
# ниже для обсуждения этой политики.
# [z_ЛИРИКА: Опечатка в оригинале? По-видимому подразумевается
# "cache_replacement_policy", т.к. тэг "replacement_policy" в конфиге отсутствует.]
#
# Установки по умолчанию:
# maximum_object_size 4096 KB
#
#  TAG: cache_swap_low	(процент, 0-100)
#  TAG: cache_swap_high	(процент, 0-100)
#
# Нижняя и верхняя границы замены кэшируемых объектов. Замена начнется, когда
# использование "swap"-а (диска) превысит нижнюю границу и (Squid) попытается удержать
# использование около нижней границы. Если использование "swap"-а приблизится к верхней
# границе, то "выселение" объектов станет более агрессивным. Если использование "swap"-а
# приблизится к нижней границе, то в единицу времени будет происходить меньше замен.
#
# По умолчанию 90% и 95% соответственно. Если у вас большой кэш, то 5% могут быть
# сотнями мегабайт. Если это так, Вы можете пожелать установить эти числа ближе
# друг к другу.
#
# Установки по умолчанию:
# cache_swap_low 90
# cache_swap_high 95
#
#
# LOGFILE OPTIONS (ОПЦИИ ЛОГ-ФАЙЛОВ)
# -----------------------------------------------------------------------------
#
#  TAG: logformat
# Использование:
#	logformat <name> <format specification>
#
# Определяет формат логфайла "access".
# <format specification> это строка с включенными "% формат-кодами"
#
# Все "% формат-коды" следуют базовой структуре и являются опциональными. Выходные строки
# автоматически экранируются ("escaped"), как требуется в соответствии с их контекстом
# и модификаторы, как правило, не требуются, но могут быть определены, если выходной
# формат явно этого требует.
#
#	% ["|[|'|#] [-] [[0]width] [{arg}] формат-код
#
#	"	Формат строки выхода, заключенной в кавычки.
#	[	Формат текстовых логов Squid-а, как используемый в "log_mime_hdrs".
#	#	Формат выхода - "URL, заключенный в кавычки".
#	'	Выход "as-is".
#
#	-	Выравнивание по левому краю.
#	width	Ширина поля. Если начинается с 0, то выход будет иметь нулевое смещение.
#	{arg}	Аргумент, такой как имя заголовка и т.п.
#
# Коды форматирования:
#	%	Литеральный символ %.
#	>a	Клиентский IP-адрес.
#	>A	Клиентский FQDN. [z_ЛИРИКА: см. http://ru.wikipedia.org/wiki/FQDN.]
#	>p	Клиентский порт.
#	<A	IP-адрес сервера или имя пира.
#	la	Локальный IP адрес ("http_port").
#	lp	Номер локального порта ("http_port").
#	ts	Прошло секунд с начала эпохи.
#	tu	Доли секунды (миллисекунды).
#	tl	Локальное время. Опциональный аргумент форматирования времени.
#		По умолчанию %d/%b/%Y:%H:%M:%S %z.
#	tg	GMT время. Опциональный аргумент форматирования времени.
#		По умолчанию %d/%b/%Y:%H:%M:%S %z.
#	tr	Время ответа (миллисекунды).
#	dt	Время, потраченное на ДНС-запрос (миллисекунды).
#
#  Коды форматирования, связанные с HTTP-кэшем:
#	[http::]>h	Оригинальный заголовок запроса. Опциональный аргумент имени
#			заголовка в формате header[:[separator]element].
#	[http::]>ha	Заголовоки HTTP-запросов после адаптации и редиректа.
#			Опциональный аргумент имени заголовка как и для ">h".
#	[http::]<h	Заголовок ответа.
#			Опциональный аргумент имени заголовка как и для ">h".
#	[http::]un	Имя пользователя.
#	[http::]ul	Имя пользователя из аутентификации.
#	[http::]ui	Имя пользователя из "ident".
#	[http::]us	Имя пользователя из SSL.
#	[http::]ue	Имя пользователя из внешней программы авторизации.
#	[http::]>Hs	Код HTTP-статуса, посланный клиенту.
#	[http::]<Hs	Код HTTP-статуса, полученный от следующего хопа.
#	[http::]Ss	Статус Squid-запроса (TCP_MISS и т.д.).
#	[http::]Sh	Иерархический статус Squid-а (DEFAULT_PARENT и т.д.).
#	[http::]mt	Тип MIME-контента.
#	[http::]rm	Метод запроса (GET/POST и т.д.).
#	[http::]ru	Запрос URL.
#	[http::]rp	Запрос URL-пути за исключением имени хоста.
#	[http::]rv	Версия протокола запроса.
#	[http::]et	Тэг, возвращенный внешним ACL.
#	[http::]ea	Лог-строка, возвращенная внешним ACL.
#	[http::]<st	Отправленный размер ответа, включающий HTTP-заголовки.
#	[http::]>st	Полученный размер запроса, включающий HTTP-заголовки.
#			В случае фрагментации запроса, фрагментированные
#			кодированные метаданные не включаются.
#	[http::]>sh	Полученный размер заголовка HTTP-запроса.
#	[http::]<sh	Отосланный размер заголовка HTTP-ответа.
#	[http::]st	Размер Запрос+Ответ, включающий HTTP-заголовки.
#===^===
#	[http::]<sH	Reply high offset sent (Увы... адекватно не переведу.
#			Верхнее смещение отправленного ответа?).
#	[http::]<sS	Upstream object size (Размер передаваемого объекта?).
#=======
#	[http::]<pt	Время ответа пира в миллисекундах. Таймер стартует когда
#			последний запрошенный байт отправлен следующему хопу,
#			и останавливается, когда получен последний ответный байт.
#	[http::]<tt	Общее время на стороне сервера в миллисекундах. Таймер стартует
#			с первым запросом на коннект (или записью I/O), отосланным
#			первому выбранному пиру. Таймер останавливается с последней
#			дисковой операцией (I/O) с последним пиром.
#
# Если ICAP включен, становятся доступными следующие два кода
# (а также коды лога ICAP, описаные в опции "icap_log")
#	icap::tt
#	Общее время ICAP-обработки HTTP-транзакции. Таймер подсчитывает время проверки
#	ACL-ов ICAP и время выполнения ICAP транзакций.
#
#	icap::<last_h
#	Заголовок последнего ICAP-ответа, связанного с HTTP-транзакцией. Как опция "<h",
#	принимает имя заголовка как опциональный аргумент. Не будет менять семантику
#	при поддержке нескольких ICAP-транзакции в одной HTTP-транзакции.
#
# Если включена адаптация, становятся доступными следующие два кода:
#	adapt::sum_trs
#	Суммированное время отклика транзакции адаптации ("Summed adaptation transaction
#	response times") записывается в виде разделенного запятыми списка, в порядке
#	транзакций по времени. Каждое временное значение записывается как целое число,
#	отображающее время отклика одной или более адаптации (ICAP или eCAP) транзакции
#	в миллисекундах. Когда неудавшаяся транзакция повторяется, ее время не логируется
#	отдельно, а добавляется к повторной транзакции. См. "adapt::all_trs".
#
#	adapt::all_trs
#	Общее время отклика транзакции адаптации. ("All adaptation transaction response
#	times.") То же самое что и "adaptation_strs", но время отклика отдельных
#	транзакций никогда не складывается. Вместо этого время отклика всех транзакций
#	записывается отдельно.
#
#	Вы можете предварять adapt::*_trs коды форматирования именем сервиса адаптации
#	в фигурных скобках для записи времени отклика, определенного для этого сервиса.
#	Например: %{my_service}adapt::sum_trs
#
#
#	Доступные форматы по умолчанию (которые не требуют переопределения):
# logformat squid %ts.%03tu %6tr %>a %Ss/%03>Hs <st %rm %ru %un %Sh/%<A %mt
# logformat squidmime %ts.%03tu %6tr %>a %Ss/%03>Hs %<st %rm %ru %un %Sh/%<A %mt [%>h] [%<h]
# logformat common %>a %ui %un [%tl] "%rm %ru HTTP/%rv" %>Hs %<st %Ss:%Sh
# logformat combined %>a %ui %un [%tl] "%rm %ru HTTP/%rv" %>Hs %<st "%{Referer}>h" "%{User-Agent}>h" %Ss:%Sh
#
# [http://www.break-people.ru/cmsmade/index.php?page=translate_squid_conf_file_section_logfile:
# При задании формата, вы указываете его имя. Оно понадобится в соответствующих
# директивах. Например, первая строчка форматов по умолчанию задаёт некоторый формат
# с именем squid. Это значит, что затем в директивах типа access_log, вам не нужно
# прописывать формат записи в журнал, а следует просто указать имя squid вместо
# <logformat name>.]
#
# Установки по умолчанию:
# none
#
#
#  TAG: access_log
# Эти файлы ведут логирование активности клиентских запросов. Каждому HTTP или
# ICP-запросу соответствует строка. Формат:
#	access_log <filepath> [<logformat name> [acl acl ...]]
#	access_log none [acl acl ...]]
#
# Будет логировать в указанный файл, используя указанный формат (который должен быть
# определен в директиве "logformat"), те записи, которые совпадают со ВСЕМИ заданными
# ACL (которые должны быть определены в секции ACL). Если не указан ни один ACL -
# все запросы будут логироваться в этот файл.
#
# Для отключения логирования запросов используйте <filepath> "none", в таком случае
# имя "logformat" не должно быть указано.
# Для логирования запросов через "syslog", укажите путь к "syslog":
#	access_log syslog[:facility.priority] [format [acl1 [acl2 ....]]]
# где "facility" может быть одним из:
#	"authpriv", "daemon", "local0" .. "local7" или "user".
# и "priority" может быть одним из:
#	"err", "warning", "notice", "info", "debug".
#
# Установки по умолчанию:
# access_log /var/log/squid/access.log squid
#
#
#  TAG: icap_log
# Лог-файлы ICAP записывают итоги ICAP-транзакций, одна строка на транзакцию.
# Формат опций icap_log:
#	icap_log <filepath> [<logformat name> [acl acl ...]]
#	icap_log none [acl acl ...]]
#
# См. документацию "access_log". Два вида журналов разделяют общий подход
# к конфигурации и много возможностей.
#
# Обработка ICAP одного HTTP-сообщения или транзакции может потребовать многократных
# ICAP-транзакций. В таких случаях несколько строк лог-файла транзакций ICAP будут
# соответствовать единственной строке в "access_log".
#
# Журнал ICAP использует коды "logformat", которые имеют смысл для транзакции ICAP.
# Связанные с заголовком коды, применимы к HTTP-заголовку, встроенному в ответ сервера
# ICAP со следующими оговорками: Для REQMOD нет HTTP-заголовка ответа, если ICAP-сервер
# не выполнил удовлетворение запроса. Для RESPMOD HTTP-заголовком запроса является
# заголовок, отправленный ICAP-серверу. Для OPTIONS нет HTTP-заголовков.
#
# [z_ЛИРИКА: Ниже приведены аналогии с "logformat"]
# Так же для ICAP-логов доступны следующие коды форматирования:
#	icap::<A		IP-адрес ICAP-сервера. Аналогично <A.
#	icap::<service_name	Имя ICAP-сервиса из опции "icap_service" конфигурационного
#				файла Squid.
#	icap::ru		ICAP URI-запрос. Аналогично ru.
#	icap::rm		ICAP метод запроса (REQMOD, RESPMOD, или OPTIONS).
#			Аналогично существующему rm.
#	icap::>st	Количество байт, отосланных ICAP-серверу (только
#			полезная нагрузка TCP; например, то, что Squid
#			записывает в сокет).
#	icap::<st	Количество байт, полученых от ICAP-сервера (только
#			полезная нагрузка TCP; например, то, что Squid
#			читает из сокета).
#	icap::tr 	Время ответа транзакции (в миллисекундах).
#			Таймер стартует во время создания ICAP-транзакции
#			и останавливается по её завершении. Аналогично tr.
#	icap::tio	I/O время транзакции (в миллисекундах).
#			Таймер стартует во время планирования отсылки первого
#			байта запроса ICAP. Таймеры останавливаются после
#			получения последнего байта от ICAP.
#	icap::to 	Результат транзакции: ICAP_ERR* для всех ошибок
#			транзакции, ICAP_OPT для OPTION транзакций,
#			ICAP_ECHO для 204 ответов, ICAP_MOD для модификации
#			сообщения, и ICAP_SAT для удовлетворения запроса.
#			Аналогично Ss.
#	icap::Hs		Код статуса ICAP-ответа. Аналогично Hs.
#	icap::>h		Заголовок(вки) ICAP-запроса. Аналогично >h.
#	icap::<h		Заголовок(вки) ICAP-ответа. Аналогично <h.
#
# Лог-формат ICAP по умолчанию, который может быть использован без явного определения
# называется "icap_squid":
#logformat icap_squid %ts.%03tu %6icap::tr %>a %icap::to/%03icap::Hs %icap::<size %icap::rm %icap::ru% %un -/%icap::<A -
#
#	См. также: "logformat", "log_icap", и "%icap::<last_h".
#
# Установки по умолчанию:
# none
#
#
#  TAG: log_access	allow|deny acl acl...
# Позволяет Вам контролировать, какие запросы будут записаны в журнал "access.log"
# (см. директиву "access_log"). Запросы, запрещенные к логированию, так же не учитываются
# счетчиками производительности.
#
# Поддерживает только быстрые [fast] типы acl.
# См. http://wiki.squid-cache.org/SquidFaq/SquidAcl
#
# Установки по умолчанию:
# none
#
#  TAG: log_icap
# Эта опция позволяет контролировать, какие запросы логируются в "icap.log".
# См. директиву icap_log.
#
# Установки по умолчанию:
# none
#
#  TAG: cache_store_log
# Ведет запись активности менеджера хранения. Показывает, какие объекты были взяты
# из кэша, и, какие объекты и как долго хранятся. Для отключения введите "none" или
# удалите строку. Для анализа этих данных не существует утилит, так что Вы можете
# безопасно отключить эту опцию.
#
# Пример:
#	cache_store_log /var/log/squid/store.log
# Установки по умолчанию:
# none
#
#  TAG: cache_swap_state
# Определяет местоположение файла "swap.state". Это индексный файл, содержащий метаданные
# об объектах, сохраненных на диск. Используется для реконструкции кэша во время запуска.
# Обычно этот файл располагается в каждой "cache_dir" директории, но Вы можете указать
# здесь альтернативный путь. Обратите внимание, Вы должны дать полный путь с именем
# файла, не только директорию. Поскольку это индекс для целого списка объектов,
# Вы НЕ МОЖЕТЕ периодически ротировать его!
#
# Если в имени файла может использоватся "%s", то в представлении имени "cache_dir" каждый
# символ "/" заменится на ".". Это необходимо для возможности добавления/удаления
# "cache_dir" строк при использовании "cache_swap_log".
#
# Если присутствует более одной "cache_dir", и "%s" не используется в имени, то эти
# "swap"-логи будут иметь имена типа:
#	cache_swap_log.00
#	cache_swap_log.01
#	cache_swap_log.02
#
# Нумерованные расширения (которые добавляются автоматически) соответствуют порядку
# строк "cache_dir" в этом конфигурационном файле. Если Вы измените порядок
# "cache_dir"-строк в этом файле, то эти индексные файлы НЕ будут соответствовать
# правильному списку "cache_dir" (если Вы вручную переименуете их). Мы рекомендуем
# НЕ ИСПОЛЬЗОВАТЬ эту опцию. Лучше хранить эти индексные файлы в каждой "cache_dir"
# директории.
#
# Установки по умолчанию:
# none
#
#  TAG: logfile_rotate
# Определяет количество ротаций лог-файла, когда Вы выполняете команду "squid -k rotate".
# По умолчанию 10, что будет ротировать с расширениями от 0 до 9. Установка
# "logfile_rotate" в 0 будет отключать ротацию имен файлов, но лог-файлы будут продолжать
# закрываться и снова открываться (т.е. данные будут писаться в существующие файлы).
# Это позволит Вам переименовывать лог-файлы самому прямо перед отправкой сигнала ротации.
#
# Заметьте, команда "squid -k rotate" обычно отправляет запущенному Squid-процессу
# сигнал USR1. В некоторых ситуациях (например, на Linux с асинхр. I/O), USR1
# используется для других целей, т.о. "-k"-ротация использует другой сигнал. Лучше
# взять в привычку использовать "squid -k rotate" вместо "kill -USR1 <pid>".
#
# Заметьте, со Squid-3.1 эта опция не оказывает эффект на "cache.log", который может
# быть ротирован отдельно, используя "debug_options".
#
# Установки по умолчанию:
# logfile_rotate 10
#
#  TAG: emulate_httpd_log	on|off
# Кэш может эмулировать формат лог-файлов, который используют многие программы "httpd".
# Для включения/выключения этой эмуляции установите "on" или "off". По умолчанию
# используется "родной" лог-формат, поскольку он включает полезную Squid-специфичную
# информацию для использования анализаторами логов.
#
# Установки по умолчанию:
# emulate_httpd_log off
#
#  TAG: log_ip_on_direct	on|off
#===^===
# Записывает IP-адрес назначения в иерархический лог-тэг (in the hierarchy log tag),
#=======
# когда он идет напрямую. Ранние версии Squid логировали здесь имя хоста. Если Вы
# предпочитаете старый способ - установите здесь значение "off".
#
# Установки по умолчанию:
# log_ip_on_direct on
#
#  TAG: mime_table
# Путь к MIME-таблице Squid-а. Вам нет нужды его менять, но если Вам надо, то в
# "default"-файле можно найти примеры и информацию по форматированию.
#
# Установки по умолчанию:
# mime_table /usr/local/etc/squid/mime.conf
#
#  TAG: log_mime_hdrs	on|off
# Кэш может записывать MIME-заголовки как запроса, так и ответа для каждой
# HTTP-транзакции. Заголовки безопасно кодируются, и будут отображаться как поля в
# квадратных скобках в конце "access"-лога (в лог-форматах либо "native", либо
# "httpd"-эмуляции). Для включения этого логирования установите "log_mime_hdrs" в "on".
#
# Установки по умолчанию:
# log_mime_hdrs off
#
#  TAG: useragent_log
# Примечание: Доступен только если Squid собран с опцией --enable-useragent-log
#
# Squid будет записывать поле "User-Agent" из HTTP-запросов в указанный здесь файл.
# По умолчанию "useragent_log" отключен.
#
# Установки по умолчанию:
# none
#
#  TAG: referer_log
# Примечание: Доступен только если Squid собран с опцией --enable-referer-log option
#
# Squid будет записывать поле "Referer" из HTTP-запросов в указанный здесь файл.
# По умолчанию "referer_log" отключен. Заметьте, что "referer" - ошибочное написание
# "referrer", однако ошибочная версия была принята в HTTP RFC-ах, и мы (Squid) принимаем
# оба слова.
#
# Установки по умолчанию:
# none
#
#  TAG: pid_filename
# Имя файла для записи "id" процесса. Для отключения введите "none".
#
# Примечание: Если Вы измените эту настройку, то Вам нужно установить "squid_pidfile"
# в /etc/rc.conf с учетом нового значения. См. /usr/local/etc/rc.d/squid.
#
# Установки по умолчанию:
# pid_filename /var/run/squid/squid.pid
#
#  TAG: log_fqdn	on|off
# Включите, если хотите записывать FQDN-имена в "access.log". Для этого Squid делает
# DNS-поиск всех подключающихся к нему IP-адресов. Это может (в некоторых случаях)
# увеличить латентность (задержку), которая заставит Ваш кэш казаться медлительнее
# для интерактивного браузинга.
#
# Установки по умолчанию:
# log_fqdn off
#
#  TAG: client_netmask
# Маска сети для клиентских адресов в лог-файлах и "выхлопе" кэш-менеджера ("cachemgr").
# Измените ее для защиты конфиденциальности Ваших кэш-клиентов.
# Маска 255.255.255.0 будет записывать все IP-адреса в этом диапазоне, с установкой
# последней цифры (вероятно подразумевается "числА") в "0".
#
# Установки по умолчанию:
# client_netmask no_addr
#
#  TAG: forward_log
# Примечание: Доступно только если Squid собран с определением -DWIP_FWD_LOG
#
# Записывает запросы сервера.
#
# На данный момент в разработке.
#
# Установки по умолчанию:
# none
#
#  TAG: strip_query_terms
# По умолчанию Squid удаляет условия (значения) из URL-запроса до логирования.
# Это защищает конфиденциальность Ваших пользователей.
#
# Установки по умолчанию:
# strip_query_terms on
#
#  TAG: buffered_logs	on|off
# Лог-файл "cache.log" написан с использованием функции "stdio", и может быть либо
# буферизован, либо нет. По умолчанию будет небуферизован. Буферизация может немного
# ускорить запись (хотя Вам вряд ли стоит беспокоится, если Вы не запущены в серьезном
# отладочном режиме ("tons of debugging"), в этом случае производительность все равно будет
# сильно страдать).
#
# Установки по умолчанию:
# buffered_logs off
#
#  TAG: netdb_filename
# Примечание: Доступно только если Squid собран с опцией --enable-icmp
#
# Имя файла, в котором Squid хранит свое "netdb"-состояние между рестартами.
# Чтобы отключить, введите "none".
#
# Установки по умолчанию:
# netdb_filename /var/log/squid/netdb.state
#
#
#
# OPTIONS FOR TROUBLESHOOTING (ОПЦИИ ПОИСКА НЕПОЛАДОК)
# -----------------------------------------------------------------------------
#
#  TAG: cache_log
# Лог-файл кэша. Здесь находится общая информация о действиях кэша.
# Вы можете увеличить количество данных, логируемых в этот файл, и частоту ротации
# с помощью "debug_options".
#
# Установки по умолчанию:
# cache_log /var/log/squid/cache.log
#
#  TAG: debug_options
# Опции логирования установлены в виде "секция,уровень", где каждому исходному файлу
# присвоена уникальная секция. Нижние уровни выдают меньший выхлоп, полный дебаг
# (уровень 9) может выдать очень большой лог-файл, по этому будьте осторожны.
#
# Волшебное слово "ALL" устанавливает уровни отладки для всех секций.
# Мы рекомендуем обычно использовать "ALL,1".
#
# Опция "rotate=N" может быть использована для хранения большего/меньшего количества
# этих журналов, чем храниться с "logfile_rotate". В большинстве случаев, единственного
# лога должно быть достаточно для мониторинга текущих событий, влияющих на Squid.
#
# Установки по умолчанию:
# debug_options ALL,1
#
#  TAG: coredump_dir
# По умолчанию Squid сохраняет "core"-файлы в директории из которой он был запущен.
# Если Вы установите "coredump_dir" в существующую директорию, Squid сделает chdir()
# в указанную директорию во время загрузки, и "coredump"-файлы будут сброшены там.
#
# Установки по умолчанию:
# coredump_dir none
# Оставить дампы в первой кэш-директории
coredump_dir /var/squid/cache
#
#
#
# OPTIONS FOR FTP GATEWAYING (ОПЦИИ FTP-ШЛЮЗОВАНИЯ)
# -----------------------------------------------------------------------------
#  TAG: ftp_user
# Если Вы хотите, чтобы анонимный вход в систему был более информативным
# (и иметь возможность использовать придирчивые FTP-сервера), укажите здесь
# что-нибудь имеющее смысл для вашего домена, типа "wwwuser@somewhere.net"
#
# По умолчанию здесь используется бездоменное (domainless) значение, так как
# запрос может быть сделан от имени пользователя в любом домене, в зависимости от того,
# как используется кэш. Некоторые ftp-сервера также проверяют адреса электронной почты
# (например perl.com).
#
# Установки по умолчанию:
# ftp_user Squid@
#
#  TAG: ftp_list_width
# Устанавливает ширину ftp-листинга (например, список файлов в директории). Должно быть
# установлено по ширине стандартного браузера. Установка слишком маленького значения
# может обрезАть длинные имена файлов во время посещения ftp-сайтов.
#
# Установки по умолчанию:
# ftp_list_width 32
#
#  TAG: ftp_passive
# Если Ваш firewall не позволяет Squid использовать пассивные соединения, выключите
# ("off") эту опцию.
#
# Использование опции "ftp_epsv_all" требует установить это значение в "ON".
#
# Установки по умолчанию:
# ftp_passive on
#
#  TAG: ftp_epsv_all
# Расширениям FTP-протокола разрешается использовать специальную команду "EPSV ALL".
# [z_ЛИРИКА: EPSV. http://panda.ispras.ru/~ipv6/ftp-alg.html ]
#
# NAT может быть способен поместить соединение в "fast path" через транслятор, т.о.
# команда EPRT никогда не будет использоваться, и поэтому, трансляция части данных
# сегментов никогда не будет нужна.
#
# Это может быть полезно, когда клиент ожидает создания только двусторонней
# передачи по FTP.
#
# Если Squid обнаруживает, что должна быть 3х-сторонняя передача данных по FTP после
# выдачи команды "EPSV ALL", FTP-сессия будет разорвана.
#
# Если у Вас есть какие-либо сомнения относительно этой опции, не используйте её.
# Сквид без проблем испробует все другие методы соединения.
#
# Для эффекта требует включения "ON" "ftp_passive" (по умолчанию).
#
# Установки по умолчанию:
# ftp_epsv_all off
#
#  TAG: ftp_epsv
# Расширениям FTP-протокола разрешается использовать специальную команду "EPSV".
#
# NAT может иметь возможность поместить соединение в "fast path" через транслятор,
# используя "EPSV", т.о. команда EPRT никогда не будет использоваться, и поэтому,
# трансляция части данных сегментов никогда не будет нужна.
#
# Установка этой опции в "OFF" предотвратит попытки использования EPSV.
# ВНИМАНИЕ! Если это сделать, поведение Squid-а вернется к старому типу, со всеми
# связанными проблемами с внешними устройствами/уровнями NAT.
#
# Для эффекта требует включения "ON" (по умолчанию (по умолчанию "off")) "ftp_passive".
#
# Установки по умолчанию:
# ftp_epsv on
#
#  TAG: ftp_sanitycheck
# По причинам безопасности и целостности данных, Squid по умолчанию производит
# "санитарную" проверку FTP-адресов с которыми происходит обмен данными, удостоверяясь
# в том, что "data"-соединение установлено с запрошенным сервером. Если вам нужно
# разрешить FTP-соединения к серверам, использующим другие IP-адреса для
# "data"-соединения, установите "off".
#
# Установки по умолчанию:
# ftp_sanitycheck on
#
#  TAG: ftp_telnet_protocol
# В протоколе FTP официально определено использование протокола telnet в качестве
# транспортного канала для контроля за соединением. Однако, многие реализации
# неработоспособны, и не уважают этот аспект протокола FTP.
#
# Если Вы имеете проблемы доступа к файлам, полное имя которых содержит ASCII-код(255)
# ("nbsp") или похожие проблемы, связанные с этим ASCII-кодом, Вы можете попытаться
# выключить ("off") эту директиву. Если это поможет, сообщите оператору FTP-сервера,
# что его сервер работает неправильно и не соответствует стандарту FTP.
#
# Установки по умолчанию:
# ftp_telnet_protocol on
#
#
# OPTIONS FOR EXTERNAL SUPPORT PROGRAMS (ОПЦИИ ПОДДЕРЖКИ ВНЕШНИХ ПРОГРАММ)
# -----------------------------------------------------------------------------
#
#  TAG: diskd_program
# Определяет расположение исполняемого файла "diskd".
# Помните, это имеет смысл только, если вы скомпилировали (Squid c) "diskd" как один из
# IO-модулей хранения (one of the store io modules).
#
# Установки по умолчанию:
# diskd_program /usr/local/libexec/squid/diskd
#
#  TAG: unlinkd_program
# Определяет расположение исполняемого файла процесса удаления файлов ("unlinkd").
#
# Установки по умолчанию:
# unlinkd_program /usr/local/libexec/squid/unlinkd
#
#  TAG: pinger_program
# Примечание: доступен только если Squid собран с опцией --enable-icmp
# Определяет расположение исполняемого файла "pinger"-процесса.
#
# Установки по умолчанию:
# pinger_program /usr/local/libexec/squid/pinger
#
#  TAG: pinger_enable
# Примечание: доступен только если Squid собран с опцией --enable-icmp
# Проверяет, является ли "pinger" активным во время выполнения.
# Управление "ICMP-pinger"-ом производится установкой "on" и "off" + просто
# "squid -k reconfigure".
#
# Установки по умолчанию:
# pinger_enable off
#
#
# OPTIONS FOR URL REWRITING (ОПЦИИ ПРЕОБРАЗОВАНИЯ URL)
# -----------------------------------------------------------------------------
#
#  TAG: url_rewrite_program
# Определяет расположение исполняемого файла "URL rewriter"-а.
# Поскольку они могут выполнять практически любые функции, ни один не включен
# (не присутствует).
#
# Для каждого запрошенного URL "rewriter" будет получать строку формата:
#	URL <SP> client_ip "/" fqdn <SP> user <SP> method [<SP> kvpairs]<NL>
#
# В будущем интерфейс "rewriter"-а будет расширен с помощью пар "key=value" ("kvpairs"
# см. выше). Программы-"rewriter"-ы должны быть готовы к получению и, возможно,
# игнорированию дополнительных разделительных пробелов-маркеров в каждой входящей строке.
#
# И "rewriter" может вернуть перезаписанный URL. Другие компоненты строки запроса
# не нуждаются в возвращении (игнорируются, если они есть).
#
# "Rewriter" может также указать, что перенаправление на стороне клиента должно
# быть выполнено к новому URL. Это делается предварением возвращенного URL-а
# префиксами "301:" (перемещен постоянно) или 302: (перемещен временно).
#
# По умолчанию "rewriter" не используется.
#
# [http://break-people.ru/cmsmade/index.php?page=translate_squid_conf_file_section_url_rewriting:
# Пример:
# url_rewrite_program /usr/local/squid/bin/squidGuard -С /usr/local/etc/squid/squidGuard.conf ]
#
# Установки по умолчанию:
# none
#
#  TAG: url_rewrite_children
# Количество порождаемых дочерних процессов редиректора. Если Вы запустите (их) слишком
# мало, Squid будет тормозить, ожидая их (освобождения) для обработки накопившихся
# URL-ов. Если Вы запустите слишком много, они будут "жрать" RAM и другие системные
# ресурсы.
#
# Установки по умолчанию:
# url_rewrite_children 5
#
#  TAG: url_rewrite_concurrency
# Количество параллельных запросов к каждому "redirector"-"хэлперу".
# По умолчанию 0, что определяет однопоточный "redirector" старого стиля.
#
# Когда эта директива установлена в значение >= 1, то протокол, используемый для связи
# с "helper"-ом, модифицируется для включения ID запроса впереди запроса/ответа.
# ID запроса от запроса должен быть повторен обратно с ответом на этот запрос.
#
# Установки по умолчанию:
# url_rewrite_concurrency 0
#
#  TAG: url_rewrite_host_header
# По умолчанию Squid перезаписывает любой "Host:"-заголовок в перенаправляемых запросах.
# Если Вы запускаете акселератор - возможно желаемого эффекта от редиректора не будет.
#
#===^===
# ПРЕДУПРЕЖДЕНИЕ: Результат процесса перезаписи URL-ов кэшируется, так что будьте
# осторожны, если у Вас есть хосты в виртуальном домене (if you have domain-virtual hosts).
#=======
#
# Установки по умолчанию:
# url_rewrite_host_header on
#
#  TAG: url_rewrite_access
# Если определен, то этот ACL указывает, какие запросы посылать процессам редиректора.
# По умолчанию посылаются все запросы.
#
# Поддерживает оба типа ACL (fast/slow)
# См. http://wiki.squid-cache.org/SquidFaq/SquidAcl.
#
# Установки по умолчанию:
# none
#
#  TAG: url_rewrite_bypass
# Когда включено, запрос не пойдет через редиректор, если все редиректоры заняты.
# Если выключено, и очередь редиректора становится очень большой, Squid будет падать
# с фатальной (FATAL) ошибкой и попросит увеличить количество редиректоров. Вы должны
# использовать эту опцию только если редиректоры не критичны для Вашей кэширующей
# системы. Если Вы используете редиректоры для контроля доступа, и Вы включили
# эту опцию, пользователи могут получить доступ к страницам, которые им запрещено
# запрашивать.
#
# Установки по умолчанию:
# url_rewrite_bypass off
#
#
#
# OPTIONS FOR TUNING THE CACHE (ОПЦИИ НАСТРОЙКИ КЭША)
# -----------------------------------------------------------------------------
#
#  TAG: cache
# Список ACL-элементов, которые, если совпадают и запрещены, являются причиной отказа
# удовлетворения запроса из кэша и запретом на кэширование результата.
# Другими словами, используйте этот тэг что бы никогда не кэшировать подобные объекты.
#
# Вы должны использовать слова "allow" или "deny" для определения будут ли объекты,
# совпадающие с ACL, разрешены или запрещены к кэшированию.
#
# Поддерживает оба типа ACL (fast/slow).
# См. http://wiki.squid-cache.org/SquidFaq/SquidAcl.
#
# По умолчанию разрешено кэшировать все.
#
# [http://break-people.ru/cmsmade/index.php?page=translate_squid_conf_file_section_tuning_the_cache">break-people.ru:
# Мы рекомендуем использовать следующие две строчки:
# acl QUERY urlpath_regex cgi-bin \?
# cache deny QUERY ]
#
# Установки по умолчанию:
# none
#
#  TAG: refresh_pattern
#	ИСПОЛЬЗОВАНИЕ: refresh_pattern [-i] regex min percent max [options]
#
# По умолчанию регулярные выражения РЕГИСТРОЗАВИСИМЫ. Чтобы сделать их
# регистроНЕзависимыми, используйте опцию -i.
#
# "Min"
# Время (в минутах) объекта без явного "срока годности", в течение которого он (объект)
# должен считаться "свежим". Рекомендуемое значение 0, любые более высокие значения
# могут стать причиной ошибочного кэширования динамических приложений, если разработчик
# (этих) приложений не принял соответствующие меры.
#
# "Percent"
# Процент от возраста объекта (возраст со времени последней модификации). Объект без
# явного "срока годности" будет считаться "свежим".
#
# "Max"
# Верхний предел того, как долго объекты без явного "срока годности" будут считаться
# "свежими".
#
#	Опции:
#		override-expire
#		override-lastmod
#		reload-into-ims
#		ignore-reload
#		ignore-no-cache
#		ignore-no-store
#		ignore-must-revalidate
#		ignore-private
#		ignore-auth
#		refresh-ims
#
#	override-expire
#	Навязывает минимальный возраст, даже если сервер послал явное истечение времени
#	(пример: в "Expires:"-заголовке или Cache-Control: max-age).
#	Использование этой опции НАРУШАЕТ стандарт HTTP. Включение этой функции может
#	сделать Вас ответственным за проблемы, которые она вызывает.
#
#	ПРИМЕЧАНИЕ: "override-expire" не навязывает устаревание - только увеличивает
#	соотношение свежесть/минута. Если сервер возвращает "Expires time", которое
#	больше, чем Ваше максимальное время, Сквид будет продолжать считать объект
#	свежим на этот период времени.
#
#	override-lastmod
#	Навязывает минимальный возраст, даже для недавно измененных объектов.
#
#	reload-into-ims
#	Изменяет клиентские "no-cache"- или "reload"-запросы на "If-Modified-Since".
#	Использование этой опции НАРУШАЕТ стандарт HTTP. Включение этой функции может
#	сделать Вас ответственным за проблемы, которые она вызывает.
#
#	ignore-reload
#	Игнорирует клиентские "no-cache"- или "reload"-заголовки.
#	Использование этой опции НАРУШАЕТ стандарт HTTP. Включение этой функции может
#	сделать Вас ответственным за проблемы, которые она вызывает.
#
#	ignore-no-cache
#	Игнорирует "Pragma: no-cache"- и "Cache-control: no-cache"-заголовки, полученные
#	от сервера. HTTP RFC никогда не позволял использование этого ("Pragma") заголовка
#	сервером, только клиентом, хотя многие сервера все равно его отсылают.
#
#	ignore-no-store
#	Игнорирует любые "Cache-control: no-store"-заголовки, полученные от сервера.
#	Использование этой опции НАРУШАЕТ стандарт HTTP. Включение этой функции может
#	сделать Вас ответственным за проблемы, которые она вызывает.
#
#	ignore-must-revalidate
#	Игнорирует любые "Cache-control: must-revalidate"-заголовки, полученные от сервера.
#	Использование этой опции НАРУШАЕТ стандарт HTTP. Включение этой функции может
#	сделать Вас ответственным за проблемы, которые она вызывает.
#
#	ignore-private
#	Игнорирует любые "Cache-control: private"-заголовки, полученные от сервера.
#	Использование этой опции НАРУШАЕТ стандарт HTTP. Включение этой функции может
#	сделать Вас ответственным за проблемы, которые она вызывает.
#
#	ignore-auth
#	Кэширует ответы на запросы с авторизацией, как если бы оригинальный сервер
#	отправил в ответе "Cache-control: public"-заголовок.
#	Использование этой опции НАРУШАЕТ стандарт HTTP. Включение этой функции может
#	сделать Вас ответственным за проблемы, которые она вызывает.
#
#	refresh-ims
#	Заставляет Squid связаться с исходным (origin) сервером, когда клиент выдает
#	"If-Modified-Since"-запрос. Это гарантирует, что клиент получит обновленную
#	версию, если таковая имеется.
#
# По существу кэшируемый объект:
#	СВЕЖИЙ если "expires" < текущего момента, иначе СТАРЫЙ
#	СТАРЫЙ если возраст > "max"
#	СВЕЖИЙ если "lm-factor" < "percent", иначе СТАРЫЙ
#	СВЕЖИЙ если возраст < "min"
#	иначе СТАРЫЙ
#
# Строки "refresh_pattern" проверяются в перечисленном здесь порядке.
# Будет использоваться первая совпавшая строка. Если ни одна строка не совпадет, то
# будут использоватся настройки по умолчанию.
#
# Заметьте, Вы должны раскоментировать все дефолтные строки, если Вы хотите
# что-то изменить. Настройки по умолчанию активны если только ничего
# не используется (не совпало?).
#
# Добавьте любую свою "refresh_pattern"-запись над этими.
refresh_pattern ^ftp:		1440	20%	10080
refresh_pattern ^gopher:		1440	0%	1440
refresh_pattern -i (/cgi-bin/|\?) 0	0%	0
refresh_pattern .			0	20%	4320
#
#  TAG: quick_abort_min		(KB)
#  TAG: quick_abort_max		(KB)
#  TAG: quick_abort_pct		(percent)
# Кэш, по умолчанию, продолжает скачивать "абортированный" запрос, который почти завершен
# (осталось менее 16 килобайт). Это может быть нежелательно на медленных (например SLIP)
# соединениях и/или очень загруженных кэшах. Нетерпеливые пользователи могут связать
# файловые дескрипторы и пропускную способность (канала) частыми запросами и
# немедленными отменами закачек.
#
# Когда пользователь прерывает запрос, Squid будет проверять значение "quick_abort",
# для вычисления объема уже переданных данных.
#
# Если осталось докачать менее "quick_abort_min" килобайт, закачка будет завершена.
#
# Если осталось докачать более "quick_abort_max" килобайт, закачка будет оборвана.
#
# Если закачано более "quick_abort_pct" процентов, закачка будет завершена.
#
# Если Вы не желаете докачек после отмены запроса клиентом, то установите обе директивы
# "quick_abort_min" и "quick_abort_max" в "0 KB".
#
# Если хотите всегда докачивать объекты, если они кэшируются, то установите
# "quick_abort_min"' в "'-1 KB"'.
#
# Установки по умолчанию:
# quick_abort_min 16 KB
# quick_abort_max 16 KB
# quick_abort_pct 95
#
#===^===
#  TAG: read_ahead_gap	(размер буфера)
# Объем данных, при получении объекта с другого сервера, которые кэш будет буферизировать
# прежде чем отправить их клиенту.
#The amount of data the cache will buffer ahead of what has been
#sent to the client when retrieving an object from another server.
#=======
#
# Установки по умолчанию:
# read_ahead_gap 16 KB
#
#  TAG: negative_ttl	(единицы времени)
# Устанавливает "время жизни" (TTL) по умолчанию для неудачных запросов.
# Некоторые типы ошибок (такие как "connection refused" и "404 Not Found") могут быть
# негативно-кэшированы на короткое время. Современные веб-сервера должны предоставлять
# "Expires:"-заголовок, впрочем, если они этого не делают, можно предоставить
# минимальный TTL.
# Умолчание не кэширует ошибки с неизвестными деталями "срока годности".
#
# Заметьте, что этот тэг отличается от негативного кэширования DNS-запросов
# (см. "negative_dns_ttl").
#
# Использование этой опции НАРУШАЕТ стандарт HTTP. Включение этой функции может
# сделать Вас ответственным за проблемы, которые она вызывает.
#
# Установки по умолчанию:
# negative_ttl 0 seconds
#
#  TAG: positive_dns_ttl	(единицы времени)
# Верхний предел времени кэширования положительных DNS-ответов.
# По умолчанию 6 часов (360 минут). Значение этой директивы должно быть больше,
# чем у "negative_dns_ttl".
#
# Установки по умолчанию:
# positive_dns_ttl 6 hours
#
#  TAG: negative_dns_ttl	(единицы времени)
# Время жизни (TTL) для негативного кэширования результатов неудачных DNS-запросов.
# Так же устанавливает наименьший лимит кэширования удачных DNS-запросов. Минимальное
# значение - 1 секунда, и не рекомендуется опускать его много ниже 10 секунд.
#
# Установки по умолчанию:
# negative_dns_ttl 1 minutes
#
#  TAG: range_offset_limit	(в байтах)
# Устанавливает верхний предел того, как далеко внутрь файла может быть сделан
# запрос диапазона ("range request"), заставляющий Squid выкачать весь файл с упреждением.
# За пределами этого лимита Squid передает запрос диапазона как есть, и результат
# НЕ кэшируется.
#
# Это запрещает слишком глубоким запросам диапазона (стартующим, скажем,
# с 17го мегабайта) заставлять Squid выкачивать объект целиком до этой точки, перед
# отсылкой каких-либо данных клиенту.
#
# Значение "0" заставляет Squid никогда не закачивать больше, чем запросил клиент.
# (по умолчанию)
#
# Значение "-1" заставляет Squid всегда закачивать объект с начала, благодаря чему он
# может кэшировать результат (стиль Squid_2.0).
#
# NP: (видимо подразумевалось "Nota Bene", либо "Notification Point". Подходящего перевода
# этой аббревиатуры не нашел)
# Использование "-1" перепишет любые настройки "quick_abort", которые, в противном случае,
# могут быть применены к диапазону запроса. Диапазон запроса будет полностью закачан
# от начала до конца независимо от действий клиента. Это значение влияет на пропускную
# способность.
#
# Установки по умолчанию:
# range_offset_limit 0 KB
#
#  TAG: minimum_expiry_time	(в секундах)
# Минимальное время кэширования объектов, в соответствии с (Expires - Date) заголовками,
# соблюдаемое Squid-ом, если объект не может быть подтвержден. По умолчанию 60 секунд.
#
# В условиях обратного прокси может быть желательным соблюдать время жизни короткоживущих
# объектов. Однако, скорее всего, будет лучше заставить Ваш сервер возвращать
# содержательный "Last-Modified"-заголовок.
#
# В условиях ESI [z_ЛИРИКА: Edge Side Includes.
# http://en.wikipedia.org/wiki/Edge_Side_Includes ],
# где фрагментированные страницы часто имеют короткое время жизни, часто бывает лучшим
# установить это значение в 0.
#
# Установки по умолчанию:
# minimum_expiry_time 60 seconds
#
#  TAG: store_avg_object_size	(в килобайтах)
# Средний размер объекта, используемый для подсчета количества объектов, которые может
# содержать Ваш кэш. По умолчанию 13 KB.
#
# Установки по умолчанию:
# store_avg_object_size 13 KB
#
#  TAG: store_objects_per_bucket
# Количество объектов на корзину в хэш-таблице хранения. Уменьшение этого значения
# увеличивает общее количество корзин, а так же интенсивность обслуживания хранилища.
# По умолчанию 20.
#
# Установки по умолчанию:
# store_objects_per_bucket 20
#
#
#
# HTTP OPTIONS (ОПЦИИ HTTP)
# -----------------------------------------------------------------------------
#
#  TAG: request_header_max_size	(в килобайтах)
# Определяет максимальный размер HTTP-заголовков в запросе. Заголовки запроса обычно
# относительно невелики (около 512 байт). Установка лимита на размер заголовка запроса
# будет ловить некоторые баги (например, в "persistent"-соединениях), и, возможно,
# переполнение буфера или DOS-атаки.
#
# Установки по умолчанию:
# request_header_max_size 64 KB
#
#  TAG: reply_header_max_size	(в килобайтах)
# Определяет максимальный размер HTTP-заголовков ответа. Заголовки ответа обычно
# относительно невелики (около 512 байт). Установка лимита на размер заголовка ответа
# будет ловить некоторые баги (например, в "persistent"-соединениях), и, возможно,
# переполнение буфера или DOS-атаки.
#
# Установки по умолчанию:
# reply_header_max_size 64 KB
#
#  TAG: request_body_max_size	(в байтах)
# Определяет максимальный размер HTTP-body запроса. Другими словами, максимальный размер
# PUT/POST запросов. Пользователь, попытавшийся отправить запрос с телом большего размера,
# чем этот лимит, получит сообщение об ошибке "Invalid request". Если Вы установите этот
# параметр в "0" (по умолчанию), то никаких лимитов применяться не будет.
#
# Установки по умолчанию:
# request_body_max_size 0 KB
#
#  TAG: chunked_request_body_max_size	(в байтах)
# Поврежденный или ненастроенный "HTTP/1.1"-клиент может отправить Squid-у разделенный
# на блоки HTTP-запрос. У Squid-а пока нет полной поддержки этой функции. Чтобы справиться
# с такими запросами, Squid буферизует весь запрос, и затем делит тело запроса, чтобы
# создать простой "HTTP/1.0"-запрос с известной длиной контента. Этот запрос используется
# остальной частью кода Squid-а как обычно.
#
# Значение опции указывает максимальный размер буфера, используемого для сбора
# запроса перед преобразованием. Если размер фрагментированного запроса превышает
# указанный предел, преобразование не производится, и клиент получает ошибку
# "unsupported request", как если бы дефрагментирование (dechunking) было отключено.
#
# По умолчанию дефрагментирование включено. Для отключения преобразования
# фрагментированных запросов установите опцию в "0" (set the maximum to zero).
#
# Возможность дефрагментации запросов и эта опция, являются временным "хаком". Когда
# дефрагментированные запросы и ответы будут полностью поддерживаться, необходимость
# в буферизации фрагментированных запросов отпадет.
#
# Установки по умолчанию:
# chunked_request_body_max_size 64 KB
#
#  TAG: broken_posts
# Список ACL-элементов, которые, если совпадают, заставляют Squid отсылать дополнительную
# пару CRLF после тела "PUT/POST"-запроса.
#
# Некоторые HTTP-серверы имеют неправильную реализацию PUT/POST, и полагаются на
# дополнительную пару CRLF посылаемую некоторыми WWW-клиентами.
#
# Цитата из RFC2616 (секция 4.1) по этому вопросу:
# Примечание: некоторые реализации "HTTP/1.0"-клиентов добавляют дополнительные "CRLF"-ы
# после POST-запроса. Повторно заявляем, что имеется явное запрещение от "BNF"
# [z_ЛИРИКА: Backus Normal Form. http://en.wikipedia.org/wiki/Backus-Naur_Form ],
# "HTTP/1.1"-клиенты не должны предварять (запросы?) или следовать запросам
# с дополнительными CRLF.
#
# Поддерживает только быстрый [fast] тип ACL
# См. http://wiki.squid-cache.org/SquidFaq/SquidAcl
#
# Пример:
# acl buggy_server url_regex ^http://....
# broken_posts allow buggy_server
#
# Установки по умолчанию:
# none
#
#  TAG: icap_uses_indirect_client	on|off
# Контролирует, будет ли ICAP-серверу в "X-Client-IP" передаваться косвенный адрес клиента
# (см. "follow_x_forwarded_for") вместо прямого.
#
# Установки по умолчанию:
# icap_uses_indirect_client on
#
#  TAG: via	on|off
# Если установлено (по умолчанию), Squid будет включать "Via"-заголовок в запросы и
# ответы, как требует RFC2616.
#
# Установки по умолчанию:
# via on
#
#  TAG: ie_refresh	on|off
# MSIE до версии 5.5 SP1 имеют проблему (при работе) с прозрачными прокси, заключающуюся
# в невозможности обновления (страницы). Включение этого тэга предоставляет частичное
# решение этой проблемы, направляя все "IMS-REFRESH"-запросы от старых версий IE на
# оригинальные сервера за свежим контентом. Это уменьшает процент попадания ("hit ratio")
# на некоторую величину (~10% по моему опыту), но позволяет пользователям постоянно иметь
# свежий контент, когда они этого хотят. Обратите внимание, поскольку Squid не может
# определить использует ли юзер IE5.5 или IE5.5SP1, то поведение Squid-а для IE версии 5.5
# не будет отличаться от поведения для более старых версий IE (например, невозможно
# принудительное обновление). Новые версии IE, надеемся, будут продолжать обладать
# новым поведением, и будут обслуживаться, основываясь на этом предположении. Этот тэг
# по умолчанию поддерживает старое поведение Squid-а, которое лучше для хит-рейта, но
# скверно для клиентов, использующих IE, если им требуется возможность принудительно
# обновлять контент.
#
# Установки по умолчанию:
# ie_refresh off
#
#  TAG: vary_ignore_expire	on|off
# Многие HTTP-сервера поддерживающие "Vary", по запросу "HTTP/1.0"-клиента, дают таким
# объектам время немедленного устаревания (нулевое время хранения) без
# "Cache-control"-заголовка. Эта опция позволяет Squid-у игнорировать такое время
# устаревания до тех пор, пока "HTTP/1.1" не будет полностью реализован.
#
# ВНИМАНИЕ: Если включить этот тэг, то это, в конечном счете, может привести к кэшированию
# не предназначенных для того объектов.
#
# Установки по умолчанию:
# vary_ignore_expire off
#
#  TAG: request_entities
# По умолчанию Squid запрещает "GET"- и "HEAD"-запросы с запросом объекта, поскольку
# смысл таких запросов не определен в "HTTP"-стандарте, хотя явно они и не запрещены.
#
# Включите эту директиву, если у вас есть клиенты, которые настаивают на отсылке
# запроса объектов в "GET"- или "HEAD"-запросах. Но будьте осторожны при включении, т.к.
# существует серверное ПО (и прокси, и веб), которое может "упасть" при обработке такого
# рода запроса, что может сделать Вас уязвимым к атакам типа "загрязнение кэша".
#
# Установки по умолчанию:
# request_entities off
#
#  TAG: request_header_access
# Использование: request_header_access header_name allow|deny [!]aclname ...
#
# ВНИМАНИЕ: Использование этой опции НАРУШАЕТ стандарт HTTP. Включение этой функции может
# сделать Вас ответственным за проблемы, которые она вызывает.
#
# Эта опция заменяет старые опции "anonymize_headers" и "http_anonymizer" чем-то более
# конфигурабельным. Этот новый метод создает список ACL для каждого заголовка, позволяя
# Вам очень тонко настраивать изменения заголовка.
#
# Эта опция применяется только к заголовкам запросов, например от клиента к серверу.
#
# Вы можете указать только известные заголовки в качестве имени заголовка. Другие
# заголовки будут классифицированы как "Other". Вы можете также обратиться ко всем
# заголовкам используя "All".
#
# Например, для достижения такого же поведения как у старой опции
# "http_anonymizer standard", Вы должны использовать:
#	request_header_access From deny all
#	request_header_access Referer deny all
#	request_header_access Server deny all
#	request_header_access User-Agent deny all
#	request_header_access WWW-Authenticate deny all
#	request_header_access Link deny all
#
# Или, для воспроизведения старой функции "http_anonymizer paranoid"
# Вы должны использовать:
#	request_header_access Allow allow all
#	request_header_access Authorization allow all
#	request_header_access WWW-Authenticate allow all
#	request_header_access Proxy-Authorization allow all
#	request_header_access Proxy-Authenticate allow all
#	request_header_access Cache-Control allow all
#	request_header_access Content-Encoding allow all
#	request_header_access Content-Length allow all
#	request_header_access Content-Type allow all
#	request_header_access Date allow all
#	request_header_access Expires allow all
#	request_header_access Host allow all
#	request_header_access If-Modified-Since allow all
#	request_header_access Last-Modified allow all
#	request_header_access Location allow all
#	request_header_access Pragma allow all
#	request_header_access Accept allow all
#	request_header_access Accept-Charset allow all
#	request_header_access Accept-Encoding allow all
#	request_header_access Accept-Language allow all
#	request_header_access Content-Language allow all
#	request_header_access Mime-Version allow all
#	request_header_access Retry-After allow all
#	request_header_access Title allow all
#	request_header_access Connection allow all
#	request_header_access All deny all
#
# Несмотря на то, что многие из них являются "HTTP"-заголовками ответа, они так же
# должны контролироваться директивой "reply_header_access".
#
# По умолчанию разрешены все заголовки (анонимность не соблюдается).
#
# Установки по умолчанию:
# none
#
#  TAG: reply_header_access
# Использование: reply_header_access header_name allow|deny [!]aclname ...
#
# ВНИМАНИЕ: Использование этой опции НАРУШАЕТ стандарт HTTP. Включение этой функции может
# сделать Вас ответственным за проблемы, которые она вызывает.
#
# Эта опция применяется только к заголовкам ответов, например от сервера к клиенту.
#
# Это то же самое что и "request_header_access", но в другом направлении.
#
# Эта опция заменяет старые опции "anonymize_headers" и "http_anonymizer" чем-то более
# конфигурабельным. Этот новый метод создает список ACL для каждого заголовка, позволяя
# Вам очень тонко настраивать изменения заголовка.
#
# Вы можете указать только известные заголовки в качестве имени заголовка. Другие
# заголовки будут классифицированы как "Other". Вы можете также обратиться ко всем
# заголовкам используя "All".
#
# Например, для достижения такого же поведения как у старой опции
# "http_anonymizer standard", Вы должны использовать:
#		reply_header_access From deny all
#		reply_header_access Referer deny all
#		reply_header_access Server deny all
#		reply_header_access User-Agent deny all
#		reply_header_access WWW-Authenticate deny all
#		reply_header_access Link deny all
#
# Или, для воспроизведения старой функции "http_anonymizer paranoid"
# Вы должны использовать:
#		reply_header_access Allow allow all
#		reply_header_access Authorization allow all
#		reply_header_access WWW-Authenticate allow all
#		reply_header_access Proxy-Authorization allow all
#		reply_header_access Proxy-Authenticate allow all
#		reply_header_access Cache-Control allow all
#		reply_header_access Content-Encoding allow all
#		reply_header_access Content-Length allow all
#		reply_header_access Content-Type allow all
#		reply_header_access Date allow all
#		reply_header_access Expires allow all
#		reply_header_access Host allow all
#		reply_header_access If-Modified-Since allow all
#		reply_header_access Last-Modified allow all
#		reply_header_access Location allow all
#		reply_header_access Pragma allow all
#		reply_header_access Accept allow all
#		reply_header_access Accept-Charset allow all
#		reply_header_access Accept-Encoding allow all
#		reply_header_access Accept-Language allow all
#		reply_header_access Content-Language allow all
#		reply_header_access Mime-Version allow all
#		reply_header_access Retry-After allow all
#		reply_header_access Title allow all
#		reply_header_access Connection allow all
#		reply_header_access All deny all
#
# Хотя контролировать заголовки HTTP-запроса этой директивой не будет удачным решением
# (см. "request_header_access").
#
# По умолчанию разрешены все заголовки (анонимность не соблюдается).
#
# Установки по умолчанию:
# none
#
#  TAG: header_replace
# Использование:   header_replace header_name message
# Пример: header_replace User-Agent Nutscrape/1.0 (CP/M; 8-bit)
#
# Эта опция позволяет Вам изменять содержимое заголовков, запрещенных "header_access"
# выше, на какую-нибудь определенную строку. Этот замена старой опции
# "fake_user_agent".
#
# Применяется только к заголовкам запросов, не к заголовкам ответов.
#
# По умолчанию заголовки удаляются, если они запрещены.
#
# Установки по умолчанию:
# none
#
#  TAG: relaxed_header_parser	on|off|warn
# Разрешает/запрещает преобразовывать некорректно оформленные заголовки HTTP-сообщений.
#
# "on" по умолчанию разрешает Squid-у принимать некоторые формы несовместимых
# HTTP-сообщений, в которых однозначно определяется, что подразумевало
# приложение-отправитель, даже если сообщение некорректно отформатировано. Затем, при
# форварде сообщения через Squid, оно нормализуется в корректную форму.
#
# Если установлено в "warn", то каждый раз, сталкиваясь с такой HTTP-ошибкой, Squid будет
# записывать предупреждение в "cache.log".
#
# Если установлено в "off", то такие HTTP-ошибки станут причиной отклонения
# запроса/ответа.
#
# Установки по умолчанию:
# relaxed_header_parser on
#
#  TAG: ignore_expect_100	on|off
# Эта опция заставляет Squid игнорировать любой "Expect: 100-continue"-заголовок
# присутствующий в запросе. [z_ЛИРИКА: см. Список кодов состояния HTTP.
# http://ru.wikipedia.org/wiki/Список_кодов_состояния_HTTP ]
# RFC 2616 требует, чтобы Squid, будучи не в состоянии удовлетворить ожидание ответа,
# ДОЛЖЕН возвращать ошибку 417.
#
# Примечание: Включение этой опции нарушает протокол HTTP, но некоторые клиенты не могут
# обрабатывать его корректно.
#
# Установки по умолчанию:
# ignore_expect_100 off
#
#
# TIMEOUTS (ТАЙМАУТЫ)
# -----------------------------------------------------------------------------
#
#  TAG: forward_timeout	(единицы времени)
# Этот параметр определяет как долго Squid должен пытаться искать форвард-путь для
# запроса прежде чем сдаться.
#
# Установки по умолчанию:
# forward_timeout 4 minutes
#
#  TAG: connect_timeout	(единицы времени)
# Этот параметр определяет как долго ожидать завершения TCP-соединения с запрошенным
# сервером или пиром, прежде чем Squid должен будет попытаться найти другой путь
# для форварда запроса.
#
# Установки по умолчанию:
# connect_timeout 1 minute
#
#  TAG: peer_connect_timeout	(единицы времени)
# Этот параметр определяет как долго ожидать TCP-соединения с кэшем пира. По умолчанию
# 30 секунд. Вы так же можете установить соседям различные индивидуальные значения
# таймаута при помощи опции "connect-timeout" в строке "cache_peer".
#
# Установки по умолчанию:
# peer_connect_timeout 30 seconds
#
#  TAG: read_timeout	(единицы времени)
# Применяется к "server-side"-соединениям. После каждого выполненного "read()", таймаут
# будет увеличен на эту величину. Если по истечении этого количества времени никаких
# данных не будет считано, запрос отменяется и логируется как "ERR_READ_TIMEOUT".
# По умолчанию, 15 минут.
#
# Установки по умолчанию:
# read_timeout 15 minutes
#
#  TAG: request_timeout
# Как долго ожидать HTTP-запроса после установки инициирующего соединения.
#
# Установки по умолчанию:
# request_timeout 5 minutes
#
#  TAG: persistent_request_timeout
# Как долго ожидать следующего HTTP-запроса в "persistent"-соединении, после
# завершения предыдущего запроса.
#
# Установки по умолчанию:
# persistent_request_timeout 2 minutes
#
#  TAG: client_lifetime	(единицы времени)
# Максимальное количество времени для клиента (браузера), разрешающее оставаться
# подключенным к кэш-процессу. Это защищает кэш от (открытия) большого числа сокетов
# (и, следовательно, файловых дескрипторов), связанных в состоянии "CLOSE_WAIT" с
# удаленными клиентами, которые некорректно отключились (по причине либо сетевых ошибок,
# либо плохой реализации клиентского ПО). По умолчанию 1 день (1440 минут).
#
# ПРИМЕЧАНИЕ: Значение по умолчанию предназначается быть бОльшим, чем потребуется любому
# клиенту быть подключеннным к Вашему кэшу. Как последний вариант, возможно Вы должны
# изменить только "client_lifetime". Если Вам кажется, что слишком много клиентов
# связывают файловые дескрипторы, мы рекомендуем сначала настроить значения тэгов
# "read_timeout", "request_timeout", "persistent_request_timeout" и "quick_abort".
#
# Установки по умолчанию:
# client_lifetime 1 day
#
#  TAG: half_closed_clients
# Некоторые клиенты могут закрывать отсылающую часть своего TCP-соединения, оставляя
# открытой принимающую часть. Иногда Squid не может определить разницу между наполовину
# закрытым и полностью закрытым TCP-соединением.
#
# По умолчанию Squid немедленно закрывает клиентское соединение, когда "read(2)"
# возвращает "no more data to read."
#
# Измените это значение на "on", и Squid будет сохранять соединения открытыми до тех пор,
# пока "read(2)" или "write(2)" в сокете не вернут ошибку.
# Это может показать некоторые преимущества для обратных прокси. Но если нет,
# рекомендуется оставить её "OFF".
#
# Установки по умолчанию:
# half_closed_clients off
#
#  TAG: pconn_timeout
# Таймаут простаивающих "persistent"-соединений с серверами и другими прокси.
#
# Установки по умолчанию:
# pconn_timeout 1 minute
#
#  TAG: ident_timeout
# Максимальное время ожидания завершения "IDENT lookup"-а.
#
# Если значение слишком велико, и Вы включили "IDENT lookup" от недоверенных
# пользователей, то вы можете быть подвержены "denial-of-service" (DOS-атакам) из-за
# множества одновременных "ident"-запросов.
#
# Установки по умолчанию:
# ident_timeout 10 seconds
#
#  TAG: shutdown_lifetime	(единицы времени)
# При получении SIGTERM или SIGHUP кэш перейдет в режим "shutdown pending" до тех пор,
# пока все активные сокеты не будут закрыты. Это значение - "время жизни" для всех
# открытых дескрипторов во время "shutdown"-режима. Любые активные клиенты, по прошествии
# указанных секунд, получат "timeout"-сообщение
#
# Установки по умолчанию:
# shutdown_lifetime 30 seconds
#
#
# ADMINISTRATIVE PARAMETERS (АДМИНИСТРАТИВНЫЕ ПАРАМЕТРЫ)
# -----------------------------------------------------------------------------
#
#  TAG: cache_mgr
# Email-адрес локального кэш-менеджера, который будет получать почту, если кэш упадет.
# По умолчанию "webmaster".
#
# Установки по умолчанию:
# cache_mgr webmaster
#
#  TAG: mail_from
# "From:"-адрес для письма, отсылаемого припадении кэша.
# По умолчанию используется "appname@unique_hostname". Значение "appname" по умолчанию
# "squid", может быть изменено в "src/globals.h" перед компиляцией Squid.
#
# Установки по умолчанию:
# none
#
#  TAG: mail_program
# Почтовая программа, используемая для отправки письма при падении кэша. По умолчанию -
# "mail". Указанная программа должна быть совместима со стандартным почтовым синтаксисом
# Unix:
#	mail-program recipient < mailfile
#
# Можно указать дополнительные опции командной строки.
#
# Установки по умолчанию:
# mail_program mail
#
#  TAG: cache_effective_user
# Если Вы запускаете Squid от root-а, этот тэг изменит эффективный/реальный UID/GID на
# (UID/GID) пользователя, указанного ниже. По умолчанию изменить на UID Squid-а.
# См. "cache_effective_group"
#
# Установки по умолчанию:
# cache_effective_user squid
#
#  TAG: cache_effective_group
# Squid устанавливает GID по дефолтному GID-у эффективного пользователя (берется из
# файла паролей) и дополнительному списку групп из группового сообщества (and
# supplementary group list from the groups membership).
#
# Если Вы хотите запускать Squid с указанным GID, независимо от группового членства
# эффективного пользователя, то установите здесь GID, под которым Вы хотите запустить
# Squid. При установке все групповые привелегии эффективного пользователя игнорируются
# и эффективными являются только (привелегии) этого GID.
#
# Если Squid запускается не от рута, то пользователь, стартующий Squid, ДОЛЖЕН БЫТЬ
# членом указанной группы.
#
# Эта опция не рекомендуется "Squid Team". Наш совет админам - сконфигурировать
# безопасный пользовательский аккаунт для Squid-а с UID/GID, отвечающими системным
# политикам.
#
# Установки по умолчанию:
# none
#
#  TAG: httpd_suppress_version_string	on|off
# Пресекает указание версии Squid-а в HTTP-заголовках и HTML-страницах ошибок.
#
# Установки по умолчанию:
# httpd_suppress_version_string off
#
#  TAG: visible_hostname
# Если Вы хотите отображать специфичное имя хоста в сообщениях об ошибках, и т.д.,
# определите его здесь. Если не указано, то будет использоваться возвращаемое значение
# функции gethostname(). Если у Вас кэш-кластер, и происходят ошибки IP-форвардинга, то Вы
# должны установить каждому кэшу индивидуальное имя в этом тэге.
#
# Установки по умолчанию:
# none
#
#  TAG: unique_hostname
# Если Вы хотите иметь несколько машин с одинаковыми "visible_hostname", Вы должны дать
# каждой машине разные "unique_hostname", чтобы можно было отлавливать зацикливание
# форвардинга.
#
# Установки по умолчанию:
# none
#
#  TAG: hostname_aliases
# Список других DNS-имен, которые имеет Ваш кэш.
#
# Установки по умолчанию:
# none
#
#  TAG: umask
# Минимальный "umask", который должен применяться во время работы прокси, в дополнение к
# "umask" установленном при запуске.
#
# По традиционному представлению восьмеричных "umask", начинайте Ваше значение с "0".
#
# Установки по умолчанию:
# umask 027
#
#
# OPTIONS FOR THE CACHE REGISTRATION SERVICE (ОПЦИИ СЕРВИСА РЕГИСТРАЦИИ КЭША)
# -----------------------------------------------------------------------------
#
# Эта секция содержит параметры для (опционального) сервиса объявления (анонса) кэша.
# Этот сервис предоставлен, чтобы помочь кэш-администраторам определять местоположение
# друг друга с целью объединения или создания иерархии кэшей.
#
# "Анонс"-сообщение отправляется Squid-ом (через UDP) регистрационной службе.
# По умолчанию, анонсы НЕ ОТПРАВЛЯЮТСЯ, пока Вы не включите их в опции "announce_period"
# (ниже).
#
# Анонсы включают имя Вашего хоста, плюс следующую информацию из этого конфигурационного
# файла:
#	http_port
#	icp_port
#	cache_mgr
#
# Вся текущая информация регулярно обрабатывается и доступна в сети на
# http://www.ircache.net/Cache/Tracker/.
#
#  TAG: announce_period
# Как часто отсылать кэш-анонсы. По умолчанию "0", что отключает отсылку анонсов.
# Для включения анонсирования Вашего кэша просто установите период анонса.
#
# Пример:	announce_period 1 day
#
# Установки по умолчанию:
# announce_period 0
#
#  TAG: announce_host
#  TAG: announce_file
#  TAG: announce_port
# Тэги "announce_host" и "announce_port" определяют имя хоста и номер порта, на который
# будут отсылаться регистрационные сообщения.
#
# По умолчанию имя хоста и порт будут установлены в "tracker.ircache.net" и "3131".
# Если присутствует аргумент "filename" ("announce_file"), то содержимое этого файла
# будет включено в анонс-сообщение.
#
# Установки по умолчанию:
# announce_host tracker.ircache.net
# announce_port 3131
#
#
# HTTPD-ACCELERATOR OPTIONS (ОПЦИИ HTTPD-АКСЕЛЕРАТОРА)
# -----------------------------------------------------------------------------
#
#  TAG: httpd_accel_surrogate_id
# Примечание: Доступно только если Squid собран с опцией --enable-esi
#
#===^===
# Суррогаты (Surrogates) (http://www.esi.org/architecture_spec_1.0.html) нуждаются в
# идентификационном маркере, чтобы контролировать _ориентацию,прицеливание_ (targeting).
# Поскольку ферма суррогатов может выполнять все те же задачи, они могут делиться
# идентификационными маркерами.
#=======
#
# Установки по умолчанию:
# httpd_accel_surrogate_id unset-id
#
#  TAG: http_accel_surrogate_remote	on|off
# Примечание: Доступно только если Squid собран с опцией --enable-esi
#
# Удаленные суррогаты (такие, как в CDN), соблюдающие (заголовок)
# Surrogate-Control: no-store-remote. Включите, чтобы Squid вел себя как удаленный
# суррогат.
# [z_ЛИРИКА: см. 2.2 Surrogate-Control Header. http://www.w3.org/TR/edge-arch ]
#
# Установки по умолчанию:
# http_accel_surrogate_remote off
#
#  TAG: esi_parser	libxml2|expat|custom
# Примечание: Доступно только если Squid собран с опцией --enable-esi
#
# Разметка ESI не является строго XML-совместимой. Пользовательский ESI-парсер
# даст более высокую производительность, но не сможет справиться с символами НЕ-ASCII
# кодировок.
#
# Установки по умолчанию:
# esi_parser custom
#
#
# DELAY POOL PARAMETERS (ПАРАМЕТРЫ "DELAY POOL")
# -----------------------------------------------------------------------------
# [z_ЛИРИКА: советую покурить следующие доки:
# http://www.bog.pp.ru/work/squid.html#delaypool
# http://uzko.ucoz.ru/publ/3-1-0-12
# http://eddnet.org/?p=334
# В связи с неадекватностью дословного перевода терминов "delay pool" и "bucket"
# приходится представить свое видение данного процесса.
# В Squid приходит поток информации, ограниченный по скорости провайдером, допустим, до
# 10 Мб/сек. Вроде общего оросительного канала. За Squid-ом эту информацию ждут
# пользователи, которые отличаются друг от друга по: 1) подсети; 2) IP-адресу; 3) логину.
# Squid является регулировщиком потоков информации. Он может резать входящий поток
# на более мелкие потоки, отправляя их конечным потребителям, основываясь на классах
# "delay pool". Т.е. "delay pool" - это схема, построенная на классах, и ограничивающая
# скорость в канале клиента - "bucket"-е. Как-то так... ]
#
# TAG: delay_pools
# Отражает количество используемых "delay pools". Например, если у Вас есть один
# "delay pool" класса 2 и один "delay pool" класса 3, то в сумме у Вас 2 "delay pool"-а.
#
# Установки по умолчанию:
# delay_pools 0
#
#  TAG: delay_class
# Определяет класс для каждого "delay pool"-а. Необходимо указывать одну строку
# "delay_class" на каждый "delay pool". Например, для определения двух "delay pool"-ов,
# одного 2-го и одного 3-го классов, настройки "delay_pools" и "delay_class" будут
# следующими [z_ЛИРИКА: По видимому описание осталось от прежней версии, а пример новый,
# потому что в примере описывается 4 "delay pool"-а со 2-го по 5-й класс.]:
#
# Пример:
#	delay_pools 4      # 4 "delay pools"-а
#	delay_class 1 2    # Первый "pool" 2-го класса
#	delay_class 2 3    # Второй "pool" 3-го класса
#	delay_class 3 4    # Третий "pool" 4-го класса
#	delay_class 4 5    # Четвертый "pool" 5-го класса
#
#
# Классы delay pool:
#	class 1		Ограничивает единый общий канал. Т.е. если скорость общего канала
#			закручена Squid-ом до 5 Мб/с, то никто больше 5Мб/с не получит,
#			несмотря на входящую скорость в 10 Мб/с.
#
#	class 2		Ограничивает единый общий канал. Делит его на 255 каналов для
#			хостов ("individual"), и ограничивает их. Т.е. если ограничение
#			на хост 1 Мб/с, то каждый хост максимально получит свой
#			гарантированный 1 Мб/с, но все 255 хостов одновременно получат
#			не более 5 Мб/с (см. class 1).
#			Индивидуальность хостов определяется 25-32 битами IPv4-адреса.
#
#	class 3		Ограничивает единый общий канал. Делит его на 255 каналов для
#			подсетей ("network"), и ограничивает их. Каждый канал подсети
#			делит на 255 каналов для хостов ("individual"), и ограничивает их.
#			Т.е. 10 Мб/с (входящая скорость) -> 5 Мб/с (ограничение общего
#			канала) -> 1 Мб/с (ограничение подсетей) -> 100 кб/с (ограничение
#			хостов). В этом случае каждый хост получит не более 100 кб/с,
#			подсеть не более 1 Мб/с и вся сеть не более 5 Мб/с.
#			Индивидуальность хостов определяется 25-32 битами IPv4-адреса.
#			Подсети определяются 17-24 битами IPv4-адреса.
#
#	class 4		То же что и в 3м классе, с дополнительным ограничением по
#			пользователям. Имеет эффект только если имя пользователя
#			устанавливается заранее - путем принудительной аутентификации
#			в Ваших правилах http_access. Пример см. в конце
#			"delay_parameters"
#
#	class 5		Запросы сгруппированы в соответствии с их тегами
#			(см. опцию "tag= reply" тэга "external_acl").
#
# ПРИМЕЧАНИЕ: Если IP адрес представить как a.b.c.d, то:
#	биты с 25 по 32 это октет "d"
#	биты с 17 по 24 это октет "c"
#	биты с 17 по 32 это "c * 256 + d"
# ПРИМЕЧАНИЕ 2: Благодаря использованию масок в "pool"-классах 2,3,4, они применяются
# только к IPv4 трафику. Классы 1 и 5 могут быть использованы с IPv6 трафиком.
#
# Установки по умолчанию:
# none
#
#  TAG: delay_access
# Используется для сопоставления, какой запрос в какой "delay pool" направлять.
#
# "delay_access" сортирует совпадения (запросов) начиная с первого "pool"-а и заканчивая
# N-ым "pool"-ом. Запрос отправляется первому "delay pool"-у на котором он разрешен.
# Если запрос не разрешен ни на одном "pool"-е, то он не задерживается (по умолчанию).
#
# Пример, если Вы хотите заворачивать "some_big_clients" в "delay pool" 1 и
# "lotsa_little_clients" в "delay pool" 2:
#	delay_access 1 allow some_big_clients
#	delay_access 1 deny all
#	delay_access 2 allow lotsa_little_clients
#	delay_access 2 deny all
#	delay_access 3 allow authenticated_clients
#
# Установки по умолчанию:
# none
#
# TAG: delay_parameters
# Определяет параметры "delay pool". Каждый "delay pool" имеет некоторое количество
# ассоциированных с ним "buckets", как разъяснено в описании "delay_class". Синтаксис
# для первого класса:
#	delay_parameters pool aggregate
#
# Для второго класса "delay pool":
#	delay_parameters pool aggregate individual
#
# Для третьего класса "delay pool":
#	delay_parameters pool aggregate network individual
#
# Для четвертого класса "delay pool":
#	delay_parameters pool aggregate network individual user
#
# Для пятого класса "delay pool":
#	delay_parameters pool tag
#
# , где переменные:
#	pool		номер "pool"-а, например число между "1" и значением "delay pool",
#			указанное как в строках "delay_class" (т.е. - число).
#	aggregate	"delay parameters" (параметры задержки) для агрегатного "bucket"
#			(class 1, 2, 3).
#	individual	"delay parameters" для индивидуального "bucket" (class 2, 3).
#	network		"delay parameters" для сетевого "bucket" (class 3).
#	user		"delay parameters" для пользовательского "bucket" (class 4).
#	tag		"delay parameters" для "tag bucket" (class 5).
#
# Пара "delay parameters" записывается в виде "restore/maximum", где "restore"
# означает количество байтов (Не битов. Модемные и сетевые скорости обычно показывают
# в битах) в секунду, которые будут передаваться в "bucket", а "maximum" это максимальное
# количество байтов, которое может находится в "bucket" в любой момент.
#
# [http://break-people.ru/cmsmade/index.php?page=translate_squid_conf_file_section_delay_pool_parameters">break-people.ru:
# Например, чтобы ограничить скорость закачивания в воронку на уровне 64 КИЛОБИТ
# в секунду, а размер воронки ограничить на уровне 128 КИЛОБИТ, то переводя в байты
# получим 64000 / 8 = 8000 байт. Помним, что 64 КИЛОБИТ это 64 * 1000 = 64000 БИТ.
# По той же схеме 128000 / 8 = 16000 байт. Используя полученные данные записываем
# delay_parameters 1 8000/16000. Вот и всё.]
#
# Например, если "delay pool" номер 1 - второго класса, как в примере выше, и используется
# строгий лимит в 64 Кбит/сек на каждый хост (плюс "накладные расходы"), без общего
# ограничения, то строка должна выглядеть так:
#
#	delay_parameters 1 -1/-1 8000/8000
#
# Помните, что число "-1" используется для обозначения "безлимита".
#
# И, если "delay pool" номер 2 - третьего класса, как в примере выше, и Вы хотите
# ограничить общий канал сети на 256 кбит/с (строгий лимит), с ограничением каждой
# 8-битной подсети на 64 кбит/с (строгий лимит), и с ограничением каждого хоста
# на 4800 бит/с, с максимальным размером "bucket" в 64 кбита для разрешения приличным
# веб-страницам грузиться с приличной скоростью (если сеть не перегружена), но
# серьезно тормозить большие закачки, то:
#	delay_parameters 2 32000/32000 8000/8000 600/8000
#
# Должна быть одна строка "delay_parameters" на каждый "delay pool".
#
# Наконец, для "delay pool" 4-го класса, как в примере - каждый пользователь будет
# ограничен 128 Кб независимо от количества подключенных рабочих станций:
#	delay_parameters 4 32000/32000 8000/8000 600/64000 16000/16000
#
# Установки по умолчанию:
# none
#
#  TAG: delay_initial_bucket_level	(в процентах, 0-100)
# Инициирующий "bucket"-процентаж используется для указания величины заполнения
# каждого "bucket"-а при запуске/реконфигурации Squid или при первых обращениях к ним
# ("bucket"-ам) хоста (во 2-м и 3-м классах, индивидуальные хосты и сети получат
# ассоциированные с ними каналы только тогда, когда их "увидит" Squid.
#
# Установки по умолчанию:
# delay_initial_bucket_level 50
#
#
# WCCPv1 AND WCCPv2 CONFIGURATION OPTIONS (ОПЦИИ КОНФИГУРАЦИИ ПРОТОКОЛА WCCPv1 И WCCPv2)
# -----------------------------------------------------------------------------
# [z_ЛИРИКА: WCCP. http://ru.wikipedia.org/wiki/WCCP ]
#
#  TAG: wccp_router
# Используйте эту опцию для указания Вашего "домашнего" маршрутизатора для Squid-а.
#
# Тэг wccp_router поддерживает один WCCP(v1) роутер.
# Тэг wccp2_router поддерживает несколько WCCPv2 роутеров.
#
# Для указания используемой версии WCCP можно использовать только один из этих тэгов
# (wccp_router или wccp2_router) в одно и то же время.
#
# Установки по умолчанию:
# wccp_router any_addr
#
#  TAG: wccp2_router
# Используйте эту опцию для указания Вашего "домашнего" маршрутизатора для Squid-а.
#
# Тэг wccp_router поддерживает один WCCP(v1) роутер.
# Тэг wccp2_router поддерживает несколько WCCPv2 роутеров.
#
# Для указания используемой версии WCCP можно использовать только один из этих тэгов
# (wccp_router или wccp2_router) в одно и то же время.
#
# Установки по умолчанию:
# wccp2_router none
#
#  TAG: wccp_version
# Эта директива уместна только если Вы нуждаетесь в установке протокола WCCP(v1) для
# некоторых очень старых и "помирающих" маршрутизаторов Cisco. Во всех остальных
# случаях директива должна быть не установлена или оставлена на дефолтных настройках.
#===^===
# Она определяет (соотносит?) внутреннюю версию протокола WCCP(v1) с 4-ой версией,
# являющейся официально документированным протоколом.
#It defines an internal version in the WCCP(v1) protocol,
#with version 4 being the officially documented protocol.
#=======
#
# По мнению некоторых пользователей, Cisco IOS версии 11.2 и ранее поддерживают только
# третью версию WCCP. Если Вы используете такие версии IOS, то возможно Вам необходимо
# изменить это значение на 3, в остальных случаях не указывайте этот параметр.
#
# Установки по умолчанию:
# wccp_version 4
#
#  TAG: wccp2_rebuild_wait
# Если включено, Squid будет ожидать завершения перестройки кэш-директории, прежде чем
# отправить первый "wccp2"-пакет "HereIAm".
#
# Установки по умолчанию:
# wccp2_rebuild_wait on
#
#  TAG: wccp2_forwarding_method
# WCCP2 позволяет устанавливать методы форвардинга между роутером/свитчем и кэшем.
# Используемые значения:
#===^===
#	gre - GRE инкапсуляция (форвард пакета через GRE/WCCP туннель)
#	l2 - L2 редирект (форвард пакета c использованием перезаписи Layer 2/MAC)
#=======
#
# Современные (с IOS 12.4) Cisco роутеры поддерживают только GRE.
# Cisco свитчи поддерживают только L2 метод перенаправления назначения.
#
# Установки по умолчанию:
# wccp2_forwarding_method gre
#
#  TAG: wccp2_return_method
# WCCP2 позволяет устанавливать методы возврата между роутером/свитчем и кэшем для
# пакетов, к которым кэш решает не обращаться.
# Используемые значения:
#===^===
#	gre - GRE инкапсуляция (форвард пакета через GRE/WCCP туннель)
#	l2 - L2 редирект (форвард пакета с использованием перезаписи Layer 2/MAC)
#=======
#
# Современные (с IOS 12.4) Cisco роутеры поддерживают только GRE.
# Cisco свитчи поддерживают только L2 метод перенаправления назначения.
#
# Если на кэш-интерфейсе была включена команда "ip wccp redirect exclude in", то
# для прокси-сервера будет безопасным использование метода перенаправления назначения l2,
# даже если эта опция установлена в GRE.
#
# Установки по умолчанию:
# wccp2_return_method gre
#
#  TAG: wccp2_assignment_method
#===^===
# WCCP2 позволяет устанавливать методы присваивания WCCP-хеша.
# Используемые значения:
#	hash - Hash assignment (присваивание хэша)
#	mask - Mask assignment (присваивание маски)
#=======
#
# Обычно маршрутизаторы Cisco поддерживают метод "hash assignment", а свитчи Cisco
# поддерживают метод "mask assignment".
#
# Установки по умолчанию:
# wccp2_assignment_method hash
#
#  TAG: wccp2_service
# WCCP2 допускает несколько траффик-сервисов. Они могут быть двух типов: "standard"
# и "dynamic". Тип "standard" определяет один сервис - http (id 0). Id "dynamic"-сервиса
# может быть с 51 по 255 включительно. Чтобы использовать "dynamic"-сервис id, нужно
# определить тип трафика, который будет перенаправлен; это достигается использованием
# опции "wccp2_service_info".
#
# "standard" тип не требует опцию "wccp2_service_info", простого указания id сервиса
# будет достаточно.
#
# Сервис MD5-аутентификации может быть включен добавлением "password=<password>"
# в конец этого объявления сервиса.
#
# Примеры:
#	wccp2_service standard 0		# для "standard"-сервиса "web-cache"
#	wccp2_service dynamic 80		# для сервиса "dynamic"-типа, который будет
#					# конкретизирован дополнительными опциями.
#	wccp2_service standard 0 password=foo
#
# Установки по умолчанию:
# wccp2_service standard 0
#
#  TAG: wccp2_service_info
# "Dynamic" WCCPv2-сервисы требуют дополнительной информации для определения траффика,
# который Вы хотите переадресовать.
#
# Формат:
#	wccp2_service_info <id> protocol=<protocol> flags=<flag>,<flag>..
#	    priority=<priority> ports=<port>,<port>..
#
# Соответствующие флаги WCCPv2:
#	+ src_ip_hash, dst_ip_hash
#	+ source_port_hash, dst_port_hash
#	+ src_ip_alt_hash, dst_ip_alt_hash
#	+ src_port_alt_hash, dst_port_alt_hash
#	+ ports_source
#
# Список портов может содержать от одной до восьми записей.
#
#	Пример:
#	wccp2_service_info 80 protocol=tcp flags=src_ip_hash,ports_source
#	    priority=240 ports=80
#
# Примечание: id сервиса должен быть определен записью в ранее указанной директиве
# "wccp2_service dynamic <id>".
#
# Установки по умолчанию:
# none
#
#  TAG: wccp2_weight
#===^===
# Каждый кэш-сервер получает присвоенный (assigned) набор хэшей мест назначения
# (a set of the destination hash), пропорциональный их весу.
#=======
#
# Установки по умолчанию:
# wccp2_weight 10000
#
#  TAG: wccp_address
#  TAG: wccp2_address
# Используйте эту опцию, если Вам требуется использовать WCCP на определенном адресе
# интерфейса.
#
# Поведение по умолчанию - не привязывать никакой конкретный адрес.
#
# Установки по умолчанию:
# wccp_address 0.0.0.0
# wccp2_address 0.0.0.0
#
#
# PERSISTENT CONNECTION HANDLING (ОБРАБОТКА PERSISTENT-СОЕДИНЕНИЙ)
# -----------------------------------------------------------------------------
# Так же см. "pconn_timeout" в секции TIMEOUTS.
#
#  TAG: client_persistent_connections
#  TAG: server_persistent_connections
# Поддержка "persistent"-соединений для клиентов и серверов. По умолчанию Squid
# использует "persistent"-соединения (когда разрешено) с клиентами и серверами.
# Вы можете использовать эту опцию для отключения "persistent"-соединений с клиентами
# и/или серверами.
#
# Установки по умолчанию:
# client_persistent_connections on
# server_persistent_connections on
#
#  TAG: persistent_connection_after_error
# С этой директивой использование "persistent"-соединений после HTTP-ошибок может быть
# отключено. Полезно, если у Вас есть клиенты, которые не в состоянии обрабатывать
# ошибки типичных (правильных) "persistent"-соединений.
#
# Установки по умолчанию:
# persistent_connection_after_error on
#
#  TAG: detect_broken_pconn
# Некоторые сервера, как оказалось, неправильно определяют использование (наличие)
# "HTTP/1.0 persistent"-соединений, даже при (наличии) несовместимых ответах, что
# является причиной существенных задержек. Эта серверная проблема в основном наблюдается
# при редиректах.
#
# При включении этой директивы Squid будет пытаться обнаруживать такие "испорченные"
# ответы и автоматически считать ответ завершенным после 10 секунд таймаута.
#
# Установки по умолчанию:
# detect_broken_pconn off
#
#
# CACHE DIGEST OPTIONS (ОПЦИИ КЭШ-ДАЙДЖЕСТА)
# -----------------------------------------------------------------------------
#
#  TAG: digest_generation
# Примечание: Доступно только если Squid собран с опцией --enable-cache-digests
#
# Определяет, будет ли сервер генерировать "Cache Digest" своего содержимого. По
# умолчанию, если Squid скомпилирован с опцией "enable-cache-digests", создание
# "Cache Digest" включено.
#
# Установки по умолчанию:
# digest_generation on
#
#  TAG: digest_bits_per_entry
# Примечание: Доступно только если Squid собран с опцией --enable-cache-digests
#
# Количество бит в "Cache Digest" сервера, которое будет ассоциировано с одной
# "Digest"-записью для каждой комбинации из HTTP-метода и публичного ключа URL.
# По умолчанию 5.
#
# Установки по умолчанию:
# digest_bits_per_entry 5
#
#  TAG: digest_rebuild_period	(в секундах)
# Примечание: Доступно только если Squid собран с опцией --enable-cache-digests
#
# Это время ожидания между пересозданиями "Cache Digest".
#
# Установки по умолчанию:
# digest_rebuild_period 1 hour
#
#  TAG: digest_rewrite_period	(в секундах)
# Примечание: Доступно только если Squid собран с опцией --enable-cache-digests
#
# Это время ожидания между записями "Cache Digest" на диск.
#
# Установки по умолчанию:
# digest_rewrite_period 1 hour
#
#  TAG: digest_swapout_chunk_size	(в байтах)
# Примечание: Доступно только если Squid собран с опцией --enable-cache-digests
#
# Количество байт (порция) "Cache Digest"-а для одной операции записи на диск.
# По умолчанию 4096 байт (4 кбайта), дефолтная своп-страница Squid-а.
#
# Установки по умолчанию:
# digest_swapout_chunk_size 4096 bytes
#
#  TAG: digest_rebuild_chunk_percentage	(процент, 0-100)
# Примечание: Доступно только если Squid собран с опцией --enable-cache-digests
#
# Процент от "Cache Digest" для одной операции сканирования. По умолчанию установлено
# 10% от "Cache Digest.
#
# Установки по умолчанию:
# digest_rebuild_chunk_percentage 10
#
#
# SNMP OPTIONS (ОПЦИИ SNMP)
# -----------------------------------------------------------------------------
#
#  TAG: snmp_port
# Номер порта, на котором Squid слушает SNMP-запросы. Для включения поддержки SNMP
# установите подходящий номер порта. SNMP-агентом Squid-а часто используется порт 3401.
# По умолчанию установлен в "0" (отключен).
#
# Пример:
#	snmp_port 3401
#
# Установки по умолчанию:
# snmp_port 0
#
#  TAG: snmp_access
# Разрешает или запрещает доступ к SNMP-порту.
#
# Любой доступ к (SNMP) агенту запрещен по умолчанию.
# Использование:
#	snmp_access allow|deny [!]aclname ...
#
# Поддерживает только быстрые [fast] типы ACL.
# См. http://wiki.squid-cache.org/SquidFaq/SquidAcl
#
# Пример:
#	snmp_access allow snmppublic localhost
#	snmp_access deny all
#
# Установки по умолчанию:
# snmp_access deny all
#
#  TAG: snmp_incoming_address
#  TAG: snmp_outgoing_address
# Так же как "udp_incoming_address", но для SNMP-порта.
#
# snmp_incoming_address	используется для SNMP-сокета, получающего сообщения
#			от SNMP-агентов.
# snmp_outgoing_address	используется для SNMP-пакетов, возвращаемых SNMP-агентам.
#
# По умолчанию "snmp_incoming_address" слушет на всех доступных сетевых интерфейсах.
#
# Если тэг "snmp_outgoing_address" не установлен, будет использоватся тот же сокет,
# что и у "snmp_incoming_address". Изменяйте только в том случае, если Вы хотите,
# чтобы ответы отправлялись с использованием другого адреса, нежели тот, на котором
# Squid слушает SNMP-запросы.
#
# Заметьте, тэги "snmp_incoming_address" и "snmp_outgoing_address" не могут иметь
# одно и то же значение, т.к. они оба используют 3401 порт.
#
# Установки по умолчанию:
# snmp_incoming_address any_addr
# snmp_outgoing_address no_addr
#
#
#
# ICP OPTIONS (ОПЦИИ ICP)
# -----------------------------------------------------------------------------
#
#  TAG: icp_port
# Номер порта, через который Squid отсылает и принимает ICP-запросы для и от соседских
# кэшей. Стандартный UDP порт для ICP - 3130. По умолчанию отключен.
#
# Пример:
#	icp_port 3130
#
# Установки по умолчанию:
# icp_port 0
#
#  TAG: htcp_port
# Номер порта, через который Squid отсылает и принимает HTCP-запросы для и от соседских
# кэшей. Для включения установите этот тэг в 4827. По умолчанию установлен в "0"
# (отключен).
#
# Пример:
#	htcp_port 4827
#
# Установки по умолчанию:
# htcp_port 0
#
#  TAG: log_icp_queries	on|off
# Если установлено ("on"), то ICP-запросы будут записываться в журнал "access.log".
# По желанию Вы можете отключить этот тэг, если ICP-загрузка ОЧЕНЬ высока или для
# упрощения анализа логов.
#
# Установки по умолчанию:
# log_icp_queries on
#
#  TAG: udp_incoming_address
# Адрес, используемый для приёма UDP-пакетов от других кэшей.
#
# Поведение по умолчанию - не связывать ни с каким определенным адресом.
#
# Изменяйте этот тэг только если Вы хотите, чтобы все UDP-запросы принимались на
# определенном интерфейсе/адресе.
#
# ПРИМЕЧАНИЕ: "udp_incoming_address" используется модулями ICP, HTCP и DNS.
# Изменение этого тэга повлияет на все эти модули одинаково.
#
# См. udp_outgoing_address
#
# Заметьте, "udp_incoming_address" и "udp_outgoing_address" не могут иметь одинаковые
# значения, так как они оба используют один и тот же порт.
#
# Установки по умолчанию:
# udp_incoming_address any_addr
#
#  TAG: udp_outgoing_address
# Адрес, используемый для отправки UDP-пакетов другим кэшам.
#
# Поведение по умолчанию - не связывать ни с каким определенным адресом. Вместо этого
# будет использоваться тот же сокет, что и (установленный в) "udp_incoming_address".
# Изменяйте этот тэг только если Вы хотите, чтобы UDP-запросы отправлялись c
# использованием другого адреса, нежели тот, на котором Squid слушает UDP-запросы от
# других кэшей.
#
# ПРИМЕЧАНИЕ: "udp_outgoing_address" используется модулями ICP, HTCP и DNS
# Изменение этого тэга повлияет на все эти модули одинаково.
#
# См. udp_incoming_address
#
# Заметьте, "udp_incoming_address" и "udp_outgoing_address" не могут иметь одинаковые
# значения, так как они оба используют один и тот же порт.
#
# Установки по умолчанию:
# udp_outgoing_address no_addr
#
#  TAG: icp_hit_stale	on|off
# Если хотите чтобы для устаревших объектов возвращался ICP_HIT, то установите
# эту опцию в "on". Если у Вас есть "sibling"-связи с кэшами в других административных
# доменах, тэг должен быть "off". Если только Вы имеете "sibling"-связи с кэшами под
# Вашим контролем, возможно будет нормально установить опцию в "on".
# Если опция включена, Ваши "sibling"-и должны использовать опцию "allow-miss" в
# своих "cache_peer"-строках для соединения с Вами.
#
# Установки по умолчанию:
# icp_hit_stale off
#
#  TAG: minimum_direct_hops
# При использовании ICMP ping-ующих приблуд, делать прямые запросы для сайтов, находящихся
# в не большем (меньшем) количестве хопов, чем указано здесь.
#
# Установки по умолчанию:
# minimum_direct_hops 4
#
#  TAG: minimum_direct_rtt
# При использовании ICMP ping-ующих приблуд, делать прямые запросы для сайтов, находящихся
# в не большем (меньшем) количестве "rtt"-миллисекунд ("round-trip-time"), чем указано здесь.
#
# Установки по умолчанию:
# minimum_direct_rtt 400
#
#  TAG: netdb_low
#  TAG: netdb_high
# Нижняя и верхняя границы для базы данных ICMP-измерений. Указывается в цифрах,
# не в процентах. По умолчанию 900 и 1000. По достижении верхней границы, записи начнут
# удаляться до достижения нижней границы.
#
# Установки по умолчанию:
# netdb_low 900
# netdb_high 1000
#
#  TAG: netdb_ping_period
# Минимальный период между замерами сайта. Должна быть, по крайней мере, такая задержка
# между удачными пингами в одну сеть. По умолчанию 5 минут.
#
# Установки по умолчанию:
# netdb_ping_period 5 minutes
#
#  TAG: query_icmp	on|off
# Включите эту опцию, если хотите просить Ваших пиров включать ICMP-данные в их
# ICP-ответы.
#
# Если Squid Вашего пира скомпилирован с опцией "--enable-icmp", то пир будет посылать
# ICMP-ping-и на оригинальный сайт сервера, указанный в полученном (пиром) URL.
# Если Вы включите эту опцию, то ICP-ответы от этого пира будут включать ICMP-данные
# (если они будут в наличие). Затем Squid выберет "родителя" с минимальным RTT до
# оригинального сервера. Когда это случится, в поле иерарахии "access.log"-а будет
# указано "CLOSEST_PARENT_MISS". Эта опция выключена по умолчанию.
#
# Установки по умолчанию:
# query_icmp off
#
#  TAG: test_reachability	on|off
# Когда значение "on", если целевого хоста НЕТ в ICMP базе данных, или (он) имеет нулевой
# RTT, то "ICP MISS"-ответы будут вместо "ICP_MISS" заменяться на "ICP_MISS_NOFETCH".
#
# Установки по умолчанию:
# test_reachability off
#
#  TAG: icp_query_timeout	(в миллисекундах)
# Обычно Squid автоматически определяет оптимальное значение таймаута ICP-запроса,
# исходя из "round-trip-time" последних ICP-запросов. Если Вы хотите переписать значение,
# определенное Squid-ом, то установите "icp_query_timeout" в ненулевое значение.
# Это значение указывается в МИЛЛИСЕКУНДАХ, следовательно, для использования 2х-секундного
# таймаута (старое значение по умолчанию), Вы должны написать:
#	icp_query_timeout 2000
#
# Установки по умолчанию:
# icp_query_timeout 0
#
#  TAG: maximum_icp_query_timeout	(в миллисекундах)
# Обычно таймаут ICP-запроса определяется динамически. Но иногда это может привести к
# очень большим значениям (скажем, 5 секунд). Используйте эту опцию для указания
# верхнего предела значения динамического таймаута. НЕ используйте эту опцию для
# постоянного использования фиксированного (вместо динамического) значения таймаута.
# Для установки фиксированного таймаута см. директиву "icp_query_timeout".
#
# Установки по умолчанию:
# maximum_icp_query_timeout 2000
#
#  TAG: minimum_icp_query_timeout	(в миллисекундах)
# Обычно таймаут ICP-запроса определяется динамически. Но иногда это может привести к
# очень маленьким таймаутам, даже меньше разброса задержек Вашего соединения из-за
# траффика. Используйте эту опцию для указания нижнего предела значения динамического
# таймаута. НЕ используйте эту опцию для постоянного использования фиксированного
# (вместо динамического) значения таймаута. Для установки фиксированного таймаута
# см. директиву "icp_query_timeout".
#
# Установки по умолчанию:
# minimum_icp_query_timeout 5
#
#  TAG: background_ping_rate	(временной интервал)
# Управляет частотой отсылки ICP-пингов к "sibling"-ам, у которых включена директива
# "background-ping".
#
# Установки по умолчанию:
# background_ping_rate 10 seconds
#
#
#
# MULTICAST ICP OPTIONS (ОПЦИИ ШИРОКОВЕЩАТЕЛЬНОЙ РАССЫЛКИ ICP)
# -----------------------------------------------------------------------------
# [z_ЛИРИКА: см. Internet Cache Protocol, секция 10.6.3
# http://etutorials.org/Server+Administration/Squid.+The+definitive+guide/Chapter+10.+Talking+to+Other+Squids/10.6+Internet+Cache+Protocol/ ]
#
#  TAG: mcast_groups
# Этот тэг определяет список "multicast"-групп, к которым Ваш сервер должен присоединиться
# для получения широковещательных ICP-запросов.
#
# ПРИМЕЧАНИЕ! Будьте очень осторожны с тем, что указываете здесь! Будьте уверены, что Вы
# понимаете разницу между ICP-запросом (query) и ICP-ответом (reply).
# Эта опция устанавливается только если Вы хотите ПРИНИМАТЬ "multicast"-запросы.
# НЕ устанавливайте эту опцию для ОТСЫЛКИ "ICP multicast" (для этого используйте
# "cache_peer"). ICP-ответы всегда отправляются через "unicast", т.о. эта опция не
# повлияет на Ваше желание получать или нет ответы от членов "multicast"-группы.
#
# Вы должны быть очень осторожны, чтобы не использовать "multicast"-адрес, который уже
# используется другой группой кэшей.
#
# Если Вы не уверены в своем понимании "multicast", пожалуйста, прочитайте
# главу "Multicast" в Squid FAQ (http://www.squid-cache.org/FAQ/).
# [z_ЛИРИКА: Корректная ссылка.
# http://wiki.squid-cache.org/Features/MultiCast?highlight=%28faqlisted.yes%29 ]
#
# Использование: mcast_groups 239.128.16.128 224.0.1.20
#
# По умолчанию Squid не слушает никакие "multicast"-группы.
#
# Установки по умолчанию:
# none
#
#  TAG: mcast_miss_addr
# Примечание: Доступно только если Squid собран с опцией -DMULTICAST_MISS_STREAM
#
# Если Вы включили эту опцию, каждый "cache miss" URL будет отсылаться на указанный
# "multicast"-адрес.
#
# НЕ включайте эту опцию, пока Вы не будете абсолютно уверены в понимании своих действий.
#
# Установки по умолчанию:
# mcast_miss_addr no_addr
#
#  TAG: mcast_miss_ttl
# Примечание: Доступно только если Squid собран с опцией -DMULTICAST_MISS_STREAM
#
#===^===
# Это "TTL"-значение для широковещательных пакетов, которые рассылаются при отключении
# широковещательных сообщений об отсутствии URL-ов в кэше.
#This is the time-to-live value for packets multicasted when multicasting off
#cache miss URLs is enabled.
#=======
# По умолчанию установлено "пределы сайта" (site scope) , т.е. 16.
#
# Установки по умолчанию:
# mcast_miss_ttl 16
#
#  TAG: mcast_miss_port
# Примечание: Доступно только если Squid собран с опцией -DMULTICAST_MISS_STREAM
#
# Это номер порта для использования в сочетании с опцией "mcast_miss_addr".
#
# Установки по умолчанию:
# mcast_miss_port 3135
#
#  TAG: mcast_miss_encode_key
# Примечание: Доступно только если Squid собран с опцией -DMULTICAST_MISS_STREAM
#
#===^===
# URL-ы, отправляемые в "multicast miss" потоке, шифруются. Это ключ шифрования.
#The URLs that are sent in the multicast miss stream are encrypted.
#=======
#
# Установки по умолчанию:
# mcast_miss_encode_key XXXXXXXXXXXXXXXX
#
#  TAG: mcast_icp_query_timeout	(в миллисекундах)
# Для "multicast"-пиров Squid регулярно отсылает ICP-"пробы" для подсчета количества
# пиров, слушающих данный "multicast"-адрес. Это значение указывает, как долго Squid
# должен ждать перед подсчетом всех ответов. По умолчанию 2000 мсек, или 2 секунды.
#
# Установки по умолчанию:
# mcast_icp_query_timeout 2000
#
#
#
# INTERNAL ICON OPTIONS (ОПЦИИ ВНУТРЕННИХ ИКОНОК)
# -----------------------------------------------------------------------------
#
#  TAG: icon_directory
# Место хранения иконок. Обычно хранятся в /usr/local/etc/squid/icons
#
# Установки по умолчанию:
# icon_directory /usr/local/etc/squid/icons
#
#  TAG: global_internal_static
# Эта директива определяет, будет ли Squid перехватывать все запросы к
# /squid-internal-static/, неважно, URL какого хоста запрашивается (по умолчанию "on"),
# или, если не должно быть сделано ничего специального для таких URL-ов, установить
# "off". Цель этой директивы - заставить иконки и т.д. работать лучше в комплексных
# кэш-иерархиях, где не всегда бывает возможно всем узлам кэш-сети добраться до сервера,
# генерирующего листинг каталога.
#
# Установки по умолчанию:
# global_internal_static on
#
#  TAG: short_icon_urls
# Если включен - Squid будет использовать короткие URL для иконок. Если отключен - будет
# возвращаться к старому поведению, включая в URL собственное имя и порт.
#
# Если Вы запускаете комплексную кэш-иерархию из "смеси" Squid и др. прокси, Вам может
# понадобиться отключить эту директиву.
#
# Установки по умолчанию:
# short_icon_urls on
#
#
# ERROR PAGE OPTIONS (ОПЦИИ СТРАНИЦ ОШИБОК)
# -----------------------------------------------------------------------------
#




#  TAG: error_directory
# Если Вы хотите создать свою собственную версию дефолтных "error"-файлов для настройки
# их соответствия Вашей компании, скопируйте "error/template" файлы в другую директорию,


# (отредактируйте их) и укажите в этом тэге путь к ним.

#
# Внимание! Эта опция отключает мультиязычную поддержку "error pages", если таковая
# используется.
#
# Squid-девелоперы заинтересованы в создании Squid-а, доступного в широком спектре
# языков. Если Вы делаете переводы для языка, который на данный момент не поддерживается
# Squid-ом, пожалуйста, рассмотрите вопрос о внесении Вашего перевода в проект.
# http://wiki.squid-cache.org/Translations.
#
# Squid-девелоперы, работающие над переводами, счастливы поддержать вставку переведенных
# "error" файлов для любых новых языков.
#
# Установки по умолчанию:
# none
#
#  TAG: error_default_language
# Устанавливает язык по умолчанию, на котором Squid будет отсылать "error"-страницы,
# если языковые настройки клиента не совпадают с наличествующими переводами.
#
# Если не установлено (по умолчанию), будет использоваться обычный English.
#
# Squid-девелоперы заинтересованы в создании Squid-а, доступного в широком спектре
# языков. Если Вы заинтересованы в создании переводов на любой язык, посетите Squid-вики.
# http://wiki.squid-cache.org/Translations.
#
# Установки по умолчанию:
# none
#
#  TAG: error_log_languages
# Записывает в "cache.log", какие языки пользователи пытаются автоматически запросить для
# переводов.
#
# Успешные запросы не логируются. Записываются только неудачные запросы, указывающие
# на то что Squid может нуждаться в обновлении переводов своих "error"-страниц.
#
# Установки по умолчанию:
# error_log_languages on
#
#  TAG: err_page_stylesheet
# Шаблон CSS-стиля для отображения дефолтных "error"-страниц Squid-а.
#
# См. http://www.w3.org/Style/CSS/
#
# Установки по умолчанию:
# err_page_stylesheet /usr/local/etc/squid/errorpage.css
#
#
#  TAG: err_html_text
# HTML-текст для включения в сообщения об ошибках. Сделайте здесь "mailto"-URL на
# адрес Вашего администратора, или просто линк на Веб-страницу Вашей организации.
#
# Для включения этой ссылки в Ваши сообщения об ошибках, Вы должны переписать шаблонные
# "error"-файлы (находятся в директории "errors"). В желаемом месте размещения
# "err_html_text" вставьте в шаблон "error"-файла тэг %L.
#
# Установки по умолчанию:
# none
#
#  TAG: email_err_data	on|off
# Если включено, информация о произошедшей ошибке будет включена в "mailto"-линки
# ERR-страниц (если установлена опция %W), т.о. тело письма будет содержать эти данные.
# Синтаксис:
#	<A HREF="mailto:%w%W">%w</A>
#
# Установки по умолчанию:
# email_err_data on
#
#  TAG: deny_info
# Использование:	deny_info err_page_name acl
# или			deny_info http://... acl
# или			deny_info TCP_RESET acl
#
# Может быть использовано для возврата ERR-страницы запросам, которые не прошли
# "http_access"-правила.
#===^===
# Squid запоминает последний (обработанный?) в "http_access" ACL, и если для этого ACL
# есть строка "deny_info", Squid возвращает соответствующую "error"-страницу.
#Squid remembers the last acl it evaluated in http_access, and if a 'deny_info' line
#exists for that ACL Squid returns a corresponding error page.
#=======
#
# Обычно последним ACL в "http_access" является "deny"-строка, которая запрещает доступ.
# Исключения из этого правила:
# - Когда Squid нуждается в запросе учетных данных аутентификации. При встрече первого
# ACL, имеющего отношение к аутентификации.
# - Когда ни одна "http_access"-строка не совпала. При обработке последнего ACL
# в "http_access"-стоке.
#
# NP (Notification Point?): Если Вы предоставляете свои собственные "error"-страницы с
# помощью тэга "error_directory", Вы можете так же определить их вашим собственным
# именем файла:
# Пример: deny_info ERR_CUSTOM_ACCESS_DENIED bad_guys
#
# Либо Вы можете указать "error"-URL. Браузеры будут перенаправлены (302) на указанный
# URL. [z_ЛИРИКА: см. Список кодов состояния HTTP.
# http://ru.wikipedia.org/wiki/Список_кодов_состояния_HTTP#302 ]
# %s в URL перенаправления будет замещена запрашиваемым URL.
#
# Либо Вы можете приказать Squid-у сбрасывать TCP-соединение, указывая "TCP_RESET".
#
# Установки по умолчанию:
# none
#
#
# OPTIONS INFLUENCING REQUEST FORWARDING
# -----------------------------------------------------------------------------
#
#  TAG: nonhierarchical_direct
# По умолчанию Squid будет отсылать любые не-иерархические запросы (либо совпадающие с
# "hierarchy_stoplist", либо запросы некэшируемого типа) напрямую оригинальному серверу.
#
# Если вы установите значение "off", то Squid предпочтет отправлять эти запросы
# "родителям".
#
# Заметьте, что в большинстве конфигураций, выключением этого тэга Вы только добавите
# задержку этому запросу, без какого-либо увеличения "global hit ratio".
#
# Если Вы внутри файрвола, то вместо этой директивы присмотритесь к "never_direct".
#
# Установки по умолчанию:
# nonhierarchical_direct on
#
#  TAG: prefer_direct
# Обычно, для большинства запросов, Squid пытается использовать "родителей". Если Вам,
# по некоторым причинам, нравится чтобы первая попытка шла напрямую, и только в случае
# ее неудачи использовался "родитель", то установите тэг в "on".
#
# Комбинируя "nonhierarchical_direct off" и "prefer_direct on" Вы можете настроить
# Squid на использование "родителей" как резервного пути, если проход напрямую
# не получается.
#
# Примечание: Если вы хотите что бы Squid использовал "родителей" для всех запросов,
# присмотритесь к директиве "never_direct". Тэг "prefer_direct" модифицирует только то,
# как Squid обращается с запросами, которые можно кэшировать.
#
# Установки по умолчанию:
# prefer_direct off
#
#  TAG: always_direct
# Использование: always_direct allow|deny [!]aclname ...
#
# Здесь Вы можете использовать ACL-элементы для определения запросов, которые должны
# ВСЕГДА форвардиться Squid-ом на оригинальный сервер, без использования каких-либо пиров.
# Например, для постоянного прямого форварда запросов на локальные сервера, игнорируя
# любых "parent"-ов или "sibling"-ов, Вы можете использовать что-то вроде:
#	acl local-servers dstdomain my.domain.net
#	always_direct allow local-servers
#
# Для постоянного форварда FTP-запросов напрямую используйте
#	acl FTP proto FTP
#	always_direct allow FTP
#
# ПРИМЕЧАНИЕ: Это похоже, но противоположно опции "never_direct". Вам необходимо знать,
# что "always_direct deny foo" НЕ то же самое, что и "never_direct allow foo". Возможно
# Вам нужно использовать "deny"-правило для исключения более специфичного случая в
# некотором другом правиле. Пример:
#	acl local-external dstdomain external.foo.net
#	acl local-servers dstdomain  .foo.net
#	always_direct deny local-external
#	always_direct allow local-servers
#
# ПРИМЕЧАНИЕ: Если Ваша цель заставить клиента форвардить запрос напрямую к оригинальному
# серверу, в обход Squid-а, то это нужно делать в клиентской конфигурации. Конфигурация
# Squid-а только говорит ему как он будет выкачивать объект.
#
# ПРИМЕЧАНИЕ: Эта директива не влияет на кэширование. Ответы кэшируются как обычно,
# даже если Вы используете "always_direct". Чтобы не кэшировать ответы см. директиву
# "cache".
#
# Поддерживает оба типа ACL [fast] и [slow].
# См. http://wiki.squid-cache.org/SquidFaq/SquidAcl.
#
# Установки по умолчанию:
# none
#
#  TAG: never_direct
# Использование:	never_direct allow|deny [!]aclname ...
#
# "never_direct" противоположность "always_direct". Пожалуйста, если не читали, то
# прочтите описание "always_direct".
#
# С "never_direct" Вы можете использовать ACL-элементы для определения запросов, которые
# НИКОГДА не будут форвардиться напрямую к оригинальным серверам. Например, что бы
# навязать использование прокси для всех запросов, кроме тех, что в локальном домене,
# используйте что-нибудь типа:
#	acl local-servers dstdomain .foo.net
#	never_direct deny local-servers
#	never_direct allow all
# или, если Squid внутри файрвола, и там, внутри файрвола, есть локальные "intranet"
# сервера, то используйте что-нибудь типа:
#	acl local-intranet dstdomain .foo.net
#	acl local-external dstdomain external.foo.net
#	always_direct deny local-external
#	always_direct allow local-intranet
#	never_direct allow all
#
# Поддерживает оба типа ACL [fast] и [slow].
# См. http://wiki.squid-cache.org/SquidFaq/SquidAcl.
#
# Установки по умолчанию:
# none
#
#
# ADVANCED NETWORKING OPTIONS (ПРОДВИНУТЫЕ СЕТЕВЫЕ ОПЦИИ)
# -----------------------------------------------------------------------------
#
#  TAG: incoming_icp_average
#  TAG: incoming_http_average
#  TAG: incoming_dns_average
#  TAG: min_icp_poll_cnt
#  TAG: min_dns_poll_cnt
#  TAG: min_http_poll_cnt
# Немного хэви вуду. Не могу поверить, что вы читаете эти строки. Вы сошли с ума? Даже
# не пытайтесь менять значения по умолчанию, пока не поймете алгоритмы описанные
# в comm_select.c! И не стреляйте в пианиста, перевел как сумел.
#
# Установки по умолчанию:
# incoming_icp_average	6
# incoming_http_average	4
# incoming_dns_average	4
# min_icp_poll_cnt	8
# min_dns_poll_cnt	8
# min_http_poll_cnt	8
#
#  TAG: accept_filter
# FreeBSD:
#===^===
# Имя "accept(2)"-фильтра для установки на слушающие сокеты Squid-а.
# The name of an accept(2) filter to install on Squid's listen socket(s).
#=======
# Эта функция, возможно, специфична для FreeBSD, и требует поддержки в ядре.
#
# Фильтр "httpready" откладывает доставку новых соединений Squid-у до тех пор, пока
# не будет получен полный HTTP-запрос. См. ман "accf_http(9)".
#
# Фильтр "dataready" откладывает доставку новых соединений Squid-у до тех пор, пока есть
# данные для обработки. См. ман "accf_dataready(9)".
#
# Linux:
# Фильтр "data" откладывает доставку новых соединений Squid-у до тех пор, пока есть
# данные для обработки TCP_ACCEPT_DEFER. Вы опционально можете указать количество секунд
# "data=N", где N - количество секунд. По умолчанию, если не указано, 30 сек.
# См. ман tcp(7).
#
# Пример:
#	FreeBSD
#		accept_filter httpready
#	Linux
#		accept_filter data
#
# Установки по умолчанию:
# none
#
#  TAG: client_ip_max_connections
# Устанавливает абсолютный лимит количества соединений, которые можно использовать
# с одного клиентского IP. Любое превышение, и Squid начнет сбрасывать новые соединения
# от клиента до тех пор, пока тот не закроет какие-нибудь линки.
#
# Заметьте, что это глобальный лимит. Он влияет на все HTTP-, HTCP-, Gopher- и
# FTP-соединения клиента. Для более точного контроля используйте ACL-ы контроля доступа.
#
# Требует включения опции "client_db" (по умолчанию (включена)).
#
# ВНИМАНИЕ!: Это может заметно замедлить трафик, получаемый через внешний прокси или
# NAT, и заставить их (прокси/NAT) возвращать своим клиентам сообщения об ошибках.
#
# Установки по умолчанию:
# client_ip_max_connections -1
#
#  TAG: tcp_recv_bufsize	(в байтах)
# Устанавливает размер приемного буфера для TCP-сокета. Возможно легче сменить настройки
# по умолчанию Вашего ядра. Для  использования дефолтного размера буфера установите "0".
#
# Установки по умолчанию:
# tcp_recv_bufsize 0 bytes
#
#
# ICAP OPTIONS (ОПЦИИ Internet Content Adaptation Protocol)
# [z_ЛИРИКА: см. Internet Content Adaptation Protocol.
# http://en.wikipedia.org/wiki/Internet_Content_Adaptation_Protocol ]
# -----------------------------------------------------------------------------
#  TAG: icap_enable	on|off
# Если Вы хотите включить поддержку ICAP-модуля, установите тэг в "on".
#
# Установки по умолчанию:
# icap_enable off
#
#  TAG: icap_connect_timeout
# Этот параметр указывает как долго ожидать установки TCP-соединения с запрошенным
# ICAP-сервером перед тем как сдаться, и, либо прекратить HTTP-соединение, либо
# обойти ошибку.
#
# Умолчание для опциональных сервисов - "peer_connect_timeout".
# Умолчание для основных сервисов - "connect_timeout".
# Если эта опция задана явно, то ее значение применяется ко всем сервисам.
#
# Установки по умолчанию:
# none
#
#  TAG: icap_io_timeout	(единицы времени)
# Этот параметр указывает как долго ожидать "I/O"-активности (ввода/вывода) установленного
# активного ICAP-соединения тем как сдаться, и, либо прекратить HTTP-соединение, либо
# обойти ошибку.
#
# По умолчанию "read_timeout".
#
# Установки по умолчанию:
# none
#
#  TAG: icap_service_failure_limit
# Лимит указывает количество ошибок, которое Squid проигнорирует во время установки
# нового TCP-соединения с ICAP-сервисом. Если количество ошибок превысит лимит, то
# ICAP-сервис не будет использован для новых ICAP-запросов до тех пор, пока не настанет
# время обновить опции ("OPTIONS") (сервиса). Для каждой службы счетчик ошибок
# сбрасывается в ноль каждый раз, когда Squid получает опции нового сервиса.
#
# Отрицательное значение отключает лимит. Без лимита ICAP-сервис не будет считаться
# отключеным из-за сбоев связи между запросами ICAP OPTIONS.
#
# Установки по умолчанию:
# icap_service_failure_limit 10
#
#  TAG: icap_service_revival_delay
# Задержка, указывающая количество секунд ожидания после неудачного запроса ICAP OPTIONS
# перед повторным запросом опций. Отказавший ICAP-сервис считается "лежащим" до тех пор,
# пока не будут получены свежие ICAP OPTIONS.
#
# Фактическая задержка не может быть меньше, чем жестко заданный минимум задержки
# в 30 секунд.
#
# Установки по умолчанию:
# icap_service_revival_delay 180
#
#  TAG: icap_preview_enable	on|off
# "ICAP Preview"-фича позволяет ICAP-серверу обрабатывать HTTP-сообщения, просматривая
# только начало сообщения, либо даже вовсе без получения тела сообщения. В некоторых
# случаях (переменных окружения) предпросмотр сильно увеличивает скорость работы ICAP.
#
#===^===
# Во время передачи ICAP OPTIONS сервер может сказать Squid-у, что HTTP-сообщения
# должны быть предпросмотрены ("previewed"), и как много (насколько глубоко они?) должно
# быть предпросмотрено.
#During an ICAP OPTIONS transaction, the server may tell>Squid what HTTP messages should
#be previewed and how big the preview should be.
#=======
# Squid не будет использовать предпросмотр, если сервер этого не запросит.
#
# Для отключения "ICAP Preview" для всех ICAP-сервисов, независимо от OPTIONS-ответов
# отдельных ICAP-серверов, установите эту опцию в "off".
#
# Пример:
#	icap_preview_enable off
#
# Установки по умолчанию:
# icap_preview_enable on
#
#  TAG: icap_preview_size
# Дефолтный размер предпросматриваемых данных, отсылаемых ICAP-серверу. -1 означает
# отсутствие предпросмотра. Это значение может быть перезаписано для каждого сервера
# (отдельно) на основании OPTIONS-запросов.
#
# Установки по умолчанию:
# icap_preview_size -1
#
#  TAG: icap_default_options_ttl
# TTL-значение по умолчанию для "ICAP OPTIONS"-ответов, которые не имеют
# "Options-TTL"-заголовка.
#
# Установки по умолчанию:
# icap_default_options_ttl 60
#
#  TAG: icap_persistent_connections	on|off
# Должен или нет Squid использовать "persistent"-соединения с ICAP-сервером.
#
# Установки по умолчанию:
# icap_persistent_connections on
#
#  TAG: icap_send_client_ip	on|off
# Этот тэг добавляет к ICAP-запросам заголовок "X-Client-IP".
#
# Установки по умолчанию:
# icap_send_client_ip off
#
#  TAG: icap_send_client_username	on|off
# Отсылает (если доступно) аутентификационное имя (username) HTTP-клиента ICAP-сервису.
# Имя кодируется согласно опции "icap_client_username_encode", и отсылается с помощью
# заголовка, указанного в опции "icap_client_username_header".
#
# Установки по умолчанию:
# icap_send_client_username off
#
#  TAG: icap_client_username_header
# Имя заголовка ICAP-запроса для использования в "icap_send_client_username".
#
# Установки по умолчанию:
# icap_client_username_header X-Client-Username
#
#  TAG: icap_client_username_encode	on|off
# Включать ли "base64"-кодирование аутентификационного имени клиента.
#
# Установки по умолчанию:
# icap_client_username_encode off
#
#  TAG: icap_service
#===^===
# Определяет одиночный (единственный?) ICAP-сервис используя следующий формат:
#Defines a single ICAP service using the following format:
#=======
#	icap_service service_name vectoring_point [options] service_url
# где:
# service_name: ID
#	Непрозрачный идентификатор, который в squid.conf должен быть уникальным
# vectoring_point: reqmod_precache|reqmod_postcache|respmod_precache|respmod_postcache
#	Указывает, в какой точке обработки транзакции должен быть активирован ICAP-сервис.
#	*_postcache vectoring point пока не поддерживаются.
#	[z_ЛИРИКА: Перевел "vectoring_point" как "точка вхождения"]
# service_url: icap://servername:port/servicepath
#	Местонахождение сервера и сервиса ICAP.
#
#	ICAP не позволяет одиночному ("single") сервису управлять и REQMOD- и
#	RESPMOD-транзакциями. Squid не соблюдает это требование. Вы можете указать
#	сервисы при помощи одинаковых "service_url" и разных "vectoring_points".
#	Вы можете даже указать столько идентичных сервисов, насколько у Вас хватит
#	фантазии давать им разные "service_names"-имена.
#
#	Опции сервиса разделяются пробелами. ICAP-сервисы поддерживают следующие
#	опции имя=значение:
#
#	bypass=on|off|1|0
#		Если установлено в "on" или "1", ICAP-сервис рассматривается как
#		опциональный. Если сервис недоступен или неисправен, Squid будет
#		пытаться игнорировать любые ошибки, и будет выдавать сообщение, как
#		если бы сервис не был включен. Не все ICAP-ошибки могут быть обойдены.
#		Если установлено в "0", ICAP-сервис рассматривается как необходимый,
#		и все ICAP-ошибки приведут к возвращению HTTP-клиенту страницы ошибки.
#
#		Bypass по умолчанию выключен: сервисы рассматриваются как необходимые.
#
#	routing=on|off|1|0
#===^===
#		Если установлено в "on" или "1", ICAP-сервису разрешается динамически
#		изменять план адаптации текущего сообщения ("current message adaptation
#		plan"), возвращая цепочку сервисов, которые будут использоваться
#		следующими.
#=======
#		Сервисы указываются используя значение "X-Next-Services"-заголовка
#		ICAP-ответа, отформатированного в виде списка имен сервисов, разделенных
#		запятыми. Каждый проименованный сервис должен быть сконфигурирован
#		в squid.conf, и должен иметь тот же метод и точку вхождения как и у
#		текущей ICAP-транзакции. Сервисы, нарушающие эти правила, игнорируются.
#		Пустое значение "X-Next-Services" приводит к пустому плану, который
#		завершает текущую адаптацию.
#
#		По умолчанию "routing" не разрешен: ICAP "X-Next-Services" заголовки
#		ответа игнорируются.
#
#	ipv6=on|off
#		Эффективен только на "split-stack" системах. По умолчанию в этих системах
#		используются только IPv4-соединения. Когда установлено "on", эта опция
#		заставит Squid использовать только IPv6-соединения для связи с этим
#		ICAP-сервисом.
#
#		Старый формат "icap_service", без дополнительных именованных параметров,
#		считается устаревшим, но поддерживается для обратной совместимости.
#
# Пример:
#	icap_service svcBlocker reqmod_precache bypass=0 icap://icap1.mydomain.net:1344/reqmod
#	icap_service svcLogger reqmod_precache routing=on icap://icap2.mydomain.net:1344/respmod
#
# Установки по умолчанию:
# none
#
#  TAG: icap_class
# Эта устаревшая опция была задокументирована для определения цепи ICAP-сервисов,
# хотя всё это определяется множеством подобных, избыточных сервисов, и цепи
# не поддерживались.
#
# Для определения набора избыточных сервисов, пожалуйста, используйте директиву
# "adaptation_service_set". Для сервис-цепочек используйте "adaptation_service_chain".
#
# Установки по умолчанию:
# none
#
#  TAG: icap_access
# Эта опция является устаревшей. Пожалуйста, используйте "adaptation_access", которая
# имеет такую же ICAP-функциональность, но имеет документацию получше и поддержку eCAP.
#
# Установки по умолчанию:
# none
#
#
# eCAP OPTIONS
# -----------------------------------------------------------------------------
#
#  TAG: ecap_enable	on|off
# Примечание: Доступно только если Squid собран с опцией --enable-ecap
#
# Проверяет, включена ли поддержка eCAP.
#
# Установки по умолчанию:
# ecap_enable off
#
#  TAG: ecap_service
# Примечание: Доступно только если Squid собран с опцией --enable-ecap
#
#===^===
# Определяет единый (единственный?) eCAP-сервис.
#Defines a single eCAP service
#=======
#	ecap_service servicename vectoring_point bypass service_url
#
# vectoring_point = reqmod_precache|reqmod_postcache|respmod_precache|respmod_postcache
#	Указывает, в какой точке обработки транзакции должен быть активирован eCAP-сервис.
#	*_postcache точки вхождения пока не поддерживаются.
# bypass = 1|0
#	Если установлена "1", eCAP-сервис рассматривается как опциональный. Если
#	сервис недоступен или неисправен, Squid будет пытаться игнорировать любые
#	ошибки и обрабатывать сообщение, как если бы сервис не был включен. Не все
#	eCAP-ошибки могут быть обойдены. Если установлено в 0, eCAP-сервис рассматривается
#	как необходимый, и все eCAP-ошибки приведут к возвращению HTTP-клиенту страницы
#	ошибки.
# service_url = ecap://vendor/service_name?custom&cgi=style&#182;meters=optional
#
# Пример:
# ecap_service service_1 reqmod_precache 0 ecap://filters-R-us/leakDetector?on_error=block
# ecap_service service_2 respmod_precache 1 icap://filters-R-us/virusFilter?config=/etc/vf.cfg
#
# Установки по умолчанию:
# none
#
#  TAG: loadable_modules
# Примечание: Доступно только если Squid собран с опцией --enable-loadable-modules
#
# Дает команду Squid-у загрузить указанный динамический модуль(ли) или активировать ранее
# загруженный модуль(ли).
# Пример:
#	loadable_modules /usr/local/lib/MinimalAdapter.so
#
# Установки по умолчанию:
# none
#
#
# MESSAGE ADAPTATION OPTIONS (ОПЦИИ АДАПТАЦИИ СООБЩЕНИЙ)
# -----------------------------------------------------------------------------
#
#  TAG: adaptation_service_set
# Настраивает упорядоченный набор подобных, избыточных сервисов. Можно использовать, когда
# доступны "hot standby" или "backup adaptation" сервера.
#	adaptation_service_set set_name service_name1 service_name2 ...
#
# Поименованные сервисы используются в порядке объявления набора. Первый подходящий
# адаптационный сервис из набора используется первым. Следующий подходящий адаптационный
# сервис пробуется тогда и только тогда, когда транзакция с предыдущим сервисом
# потерпела неудачу, и сообщение ожидания адаптации остается без изменений.
#
#===^===
# Когда адаптация стартовала, нерабочие сервисы игнорируются как если бы они не были
# частью набора. Нерабочий сервис является "упавшим" опциональным сервисом.
#When adaptation starts, broken services are ignored as if they were
#not a part of the set. A broken service is a down optional service.
#=======
#
# Сервисы в наборе должны быть присоединены к одной точке вхождения (например,
# "pre-cache") и должны использовать одинаковые адаптационные методы (например, REQMOD).
#
# Если все сервисы в наборе опциональны, то неудачи адаптации обходимы. Если все
# сервисы в наборе важны, то неудачу транзакции одного сервиса по прежнему можно
# исправить, используя повторный запрос другого сервиса из набора, но когда все сервисы
# потерпят неудачу - основная транзакция является неудачной.
#
# Набор может содержать смесь опциональных и основных сервисов, но это, вероятно,
# приведет к удивительным результатам, поскольку неотработавшие сервисы становятся
# игнорируемыми (см. выше), делая ранее обходимые ошибки фатальными. Технически имеет
# значение "обходимость" последнего неотработавшего сервиса.
#
# См: adaptation_access adaptation_service_chain
#
# Пример:
#	adaptation_service_set svcBlocker urlFilterPrimary urlFilterBackup
#	adaptation service_set svcLogger loggerLocal loggerRemote
#
# Установки по умолчанию:
# none
#
#  TAG: adaptation_service_chain
# Конфигурирует список дополнительных сервисов, которые будут применены один за другим,
# образуя адаптационную цепь или "pipeline". Полезно, когда Squid должен выполнить
# различные адаптации в одном сообщении.
#	adaptation_service_chain chain_name service_name1 svc_name2 ...
#
# Проименованные сервисы используются в порядке объявления цепочки. Первый подходящий
# адаптационный сервис в цепочке используется первым. Следующий подходящий сервис
# применяется к результатам успешной адаптации предыдущего сервиса в цепочке.
#
# Когда адаптация стартовала, нерабочие сервисы игнорируются как если бы они не были
# частью цепочки. Нерабочий сервис является "упавшим" опциональным сервисом.
#
# Удовлетворение запроса завершает адаптационную цепь, поэтому в настоящее время Squid
# не разрешает объявление RESPMOD-сервисов в "reqmod_precache" точке вхождения
# (см. "icap_service" или "ecap_service").
#
# Сервисы в цепочке должны быть присоединены к одной точке вхождения (например,
# "pre-cache") и должны использовать одинаковые адаптационные методы (например, REQMOD).
#
# Цепочка может содержать смесь опциональных и основных сервисов. Если основная
# адаптация терпит неудачу (или ошибка не может быть обойдена по другим причинам),
# основная транзакция является неудачной. Иначе неудача обходится так, как если бы
# неотработавший адаптационный сервис не был частью цепи.
#
# См: adaptation_access adaptation_service_set
#
# Пример:
#	adaptation_service_chain svcRequest requestLogger urlFilter leakDetector
#
# Установки по умолчанию:
# none
#
#  TAG: adaptation_access
# Отсылает HTTP-транзакции ICAP или eCAP адаптационным сервисам.
#	adaptation_access service_name allow|deny [!]aclname...
#	adaptation_access set_name     allow|deny [!]aclname...
#
# В каждой поддерживаемой точке вхождения, выражения "adaptation_access" обрабатываются
# в порядке указания в этом конфигурационном файле. Выражения, указывающие на следующие
# сервисы, игнорируются (т.е. "скипаются" без проверки их ACL):
#	- сервисы обслуживают разные точки вхождения
#	- "broken-but-bypassable" (сломаный-но-обходимый) сервисы
#	- "up" сервисы, сконфигурированные на игнорирование таких транзакций
#	  (например, основанные на ICAP-заголовке "Transfer-Ignore").
#
# Когда используется "set_name", все сервисы в наборе проверяются с использованием
# одинаковых правил, до нахождения первого применимого. См. "adaptation_service_set".
#
# Если ACL проверен, и в нем есть совпадение, обработка останавливается:
# Для правил "allow" для транзакции используется соответствующий адаптационный сервис.
# Для правил "deny" адаптационный сервис не активируется.
#
# На данный момент невозможно применять более чем один адаптационный сервис в одной
# точке вхождения к одной HTTP-транзакции.
# См.: "icap_service" и "ecap_service".
#
# Пример:
#	adaptation_access service_1 allow all
#
# Установки по умолчанию:
# none
#
#  TAG: adaptation_service_iteration_limit
# Ограничивает число итераций, разрешенных при применении к сообщению адаптационных
# сервисов. Если ваш самый длинный адаптационный набор или цепочка могут иметь более 16
# сервисов, увеличьте лимит за пределы значения по умолчанию, равные 16. Если критично
# обнаружение петель бесконечных циклов, то сделайте итерационный лимит, совпадающий
# с фактическим количеством сервисов в вашем наидлиннейшем адаптационном наборе или цепи.
#
# Петли бесконечных адаптаций чаще всего связаны с маршрутизацией сервисов.
#
# См.: icap_service routing=1
#
# Установки по умолчанию:
# adaptation_service_iteration_limit 16
#
#  TAG: adaptation_masterx_shared_names
# Для каждой основной ("master") транзакции (например, HTTP-последовательность
# запрос-ответ, включающая все "родственные" ICAP и eCAP обмены), Squid сохраняет
# таблицу метаданных. Табличные записи состоят из пар (name, value), распределяющихся
# между обменами eCAP и ICAP. Таблица уничтожается вместе с основной транзакцией.
#
# Эта опция определяет имена записей таблицы, которые Squid должен принять от и отправить
# к адаптивным транзакциям.
#
# ICAP-транзакции REQMOD или RESPMOD могут установить записи в разделяемой (расшариваемой)
# таблице возвратом поля ICAP-заголовка с именем, указанным в
# "adaptation_masterx_shared_names". Squid сохранит и передаст это поле ICAP-заголовка
# последующим подтранзакциям ICAP в пределах видимости основной транзакции.
#
# В данный момент поддерживается только одно общее имя записи.
#
# Пример:
## разделение аутентификационной информации между ICAP-сервисами.
#	adaptation_masterx_shared_names X-Subscriber-ID
#
# Установки по умолчанию:
# none
#
#  TAG: icap_retry
#===^===
# Этот ACL определяет, какие ICAP-транзакции, имеющие возможность повтора, будут
# повторяться. Транзакции, получившие полный ICAP-ответ и не использующие или не
# создающие HTTP-body для получения этого ответа, обычно имеют возможность повтора.
#This ACL determines which retriable ICAP transactions are retried. Transactions that
#received a complete ICAP response and did not have to consume or produce HTTP bodies
#to receive that response are usually retriable.
#	icap_retry allow|deny [!]aclname ...
#
# Squid автоматически повторяет попытки (связи из-за) некоторых таймаутов ввода/вывода
# ICAP и ошибок условий гонки "persistent"-соединений.
#Squid automatically retries some ICAP I/O timeouts and errors due to persistent
#connection race conditions.
#=======
#
# См.: "icap_retry_limit"
#
# Установки по умолчанию:
# icap_retry deny all
#
#  TAG: icap_retry_limit
# Лимитирует число разрешенных повторных попыток. Когда установлено в "0" (по умолчанию)
# попытки не разрешены.
#
# Ошибки связи из-за условий гонок "persistent"-соединений неизбежны, автоматически
# переповторяются и не считаются этим лимитом.
#
# См.: "icap_retry"
#
# Установки по умолчанию:
# icap_retry_limit 0
#
#
# DNS OPTIONS (ОПЦИИ DNS)
# -----------------------------------------------------------------------------
#
#  TAG: check_hostnames
# По причинам безопасности и стабильности Squid может проверять имена хостов на
# соответствие интернет-стандартам (RFC). Если Вы хотите, чтобы Squid делал такую
# проверку, установите эту директиву в "on".
#
# Установки по умолчанию:
# check_hostnames off
#
#  TAG: allow_underscore
# Символ подчеркивания строго не допускается в именах Интернет-хостов, но всё же
# используется многими сайтами. Установите здесь "off", если Вы хотите, чтобы Squid
# строго соблюдал стандарт. Эта проверка производится только, если тэг "check_hostnames"
# установлен в "on".
#
# Установки по умолчанию:
# allow_underscore on
#
#  TAG: cache_dns_program
# Примечание: Доступно только если Squid собран с опцией --disable-internal-dns
#
# Определяет местоположение исполняемого файла "dnslookup"-процесса.
#
# Установки по умолчанию:
# cache_dns_program /usr/local/libexec/squid/dnsserver
#
#  TAG: dns_children
# Примечание: Доступно только если Squid собран с опцией --disable-internal-dns
#
# Количество порождаемых процессов для поиска DNS-имен. Для тяжко нагруженных кэшей на
# крупных серверах, Вам, возможно, придется увеличить это значение по крайней мере до 10.
# Максимум - 32. По умолчанию - 5.
#
# Вы должны иметь хотя бы один DNS-сервер.
#
# Установки по умолчанию:
# dns_children 5
#
#  TAG: dns_retransmit_interval
# Начальный интервал повторной отправки для DNS-запросов. Интервал удваивается каждый раз
# после опроса всех сконфигурированных DNS-серверов.
#
# Установки по умолчанию:
# dns_retransmit_interval 5 seconds
#
#  TAG: dns_timeout
# Таймаут DNS-запроса. Если за это время не получено ответа на DNS-запрос, то все
# сервера запрошенного домена считаются недоступными.
#
# Установки по умолчанию:
# dns_timeout 2 minutes
#
#  TAG: dns_defnames	on|off
# Обычно опция резольвера RES_DEFNAMES отключена (см. "res_init(3)").
#===^===
# Это предотвращает в иерархических кэшах локальную интерпретацию однокомпонентных имен
# хостов.
#This prevents caches in a hierarchy from interpreting single-component hostnames locally.
#=======
# Для разрешения Squid-у обрабатывать однокомпонентные имена, включите эту опцию.
#
# Установки по умолчанию:
# dns_defnames off
#
#  TAG: dns_nameservers
# Используйте этот тэг, если хотите указать список DNS-имен серверов (IP адреса) для
# использования вместо тех, что даны в Вашем /etc/resolv.conf файле. На Windows-платформах,
# если никакого значения здесь или в /etc/resolv.conf не указано, список DNS-имен серверов
# возьмется из реестра Windows, поддерживается и статическая, и динамическая DHCP
# конфигурации.
#
# Пример:	dns_nameservers 10.0.0.1 192.172.0.4
#
# Установки по умолчанию:
# none
#
#  TAG: hosts_file
# Местоположение базы данных ассоциаций "хост-локальный IP", "имя-адрес". Большинство ОС
# располагают по умолчанию такой файл в разных местах:
#	- Un*X & Linux:    /etc/hosts
#	- Windows NT/2000: %SystemRoot%\system32\drivers\etc\hosts
#			   (%SystemRoot% значение установки по умолчанию c:\winnt)
#	- Windows XP/2003: %SystemRoot%\system32\drivers\etc\hosts
#			   (%SystemRoot% значение установки по умолчанию c:\windows)
#	- Windows 9x/Me:   %windir%\hosts
#			   (%windir% значение обычно c:\windows)
#	- Cygwin:          /etc/hosts
#
# Файл содержит определения, разделенные символом новой строки, в форме
# IP-адрес имя [имя ...]
# имена разделяются пробелом. Строки, начинающиеся с символа "#", являются комментариями.
#
# Файл проверяется во время старта и этапе конфигурации. Если установить в "none", то он
# не будет проверяться. Если используется тэг "append_domain", то его домен будет добавлен
# в определения хостов локального домена (т.е. не содержащие символ точки).
#
# Установки по умолчанию:
# hosts_file /etc/hosts
#
#  TAG: append_domain
# Добавляет имя локального домена к имени хоста, в котором нет ни одной точки. Тэг
# "append_domain" должен начинаться с символа ".".
#
# Предупреждаем, что сейчас Интернет-имена без точек используются только для имен
# доменов верхнего уровня, поэтому настройка этого тэга может стать причиной недоступности
# некоторых сайтов.
#
# Пример:
#	append_domain .yourdomain.com
#
# Установки по умолчанию:
# none
#
#  TAG: ignore_unknown_nameservers
# По умолчанию Squid проверяет, что DNS-ответы получены с того же IP-адреса к которому
# они (запросы) были отправлены. Если они не совпадают, Squid игнорирует ответ и запишет
# предупреждение в "cache.log". Вы можете разрешить ответы с неизвестных DNS-серверов,
# установив эту опцию в "off".
#
# Установки по умолчанию:
# ignore_unknown_nameservers on
#
#  TAG: dns_v4_fallback
# Стандартная практика DNS - поиск либо A, либо AAAA записей и использование результатов
# успешных запросов. Другой поиск производится только если первая попытка не удалась или
# не дала результата.
# [z_ЛИРИКА: см. DNS. http://ru.wikipedia.org/wiki/DNS ]
#
# Однако эта политика заставляет Squid выдавать страницы ошибок для некоторых серверов,
# которые объявляются как AAAA-записи, но недоступны по IPv6.
#
# Если эта опция включена (ON) Squid всегда будет искать и использовать обе записи
# AAAA и A. Если эта опция выключена (OFF), то Squid будет искать AAAA-запись,
# а A-запись будет использовать только если АААА-запись не будет найдена.
#
# ВНИМАНИЕ: При включении этой опции возможны некоторые нежелательные побочные эффекты:
#	*) Удвоение Squid-ом нагрузки на DNS-сеть.
#===^===
#	*) Может негативно отразиться задержкой времени соединения.
#*) May negatively impact connection delay times.
#=======
#
# Установки по умолчанию:
# dns_v4_fallback on
#
#  TAG: ipcache_size	(число записей)
#  TAG: ipcache_low	(в процентах)
#  TAG: ipcache_high	(в процентах)
# Размер, нижняя и верхняя границы IP-кэша.
#
# Установки по умолчанию:
# ipcache_size 1024
# ipcache_low 90
# ipcache_high 95
#
#  TAG: fqdncache_size	(число записей)
# Максимальное число FQDN-записей кэша.
#
# Установки по умолчанию:
# fqdncache_size 1024
#
#
# MISCELLANEOUS (РАЗНОЕ)
# -----------------------------------------------------------------------------
#
#  TAG: memory_pools	on|off
# Если установлено, Squid будет хранить пулы выделенной (но неиспользуемой) памяти,
# доступной для использования в будущем. Если память очень важна для Вашей системы, и Вы
# верите, что Ваша "malloc"-библиотека выигрывает у подпрограмм Squid-а, отключите эту
# опцию.
#
# Установки по умолчанию:
# memory_pools on
#
#  TAG: memory_pools_limit	(bytes)
# Используется только с включенным ("on") "memory_pools":
#	memory_pools_limit 50 MB
#
# Если установлено ненулевое значение, Squid будет хранить в пулах памяти наибольшее,
# в указанных лимитах, количество выделенной (но неиспользуемой) памяти. Все
# "free()"-запросы, превышающие этот лимит, будут обрабатываться Вашей
# "malloc"-библиотекой. Squid не резервирует память заранее, просто хранит в безопасности
# объекты, которые иначе были бы "освобождены" ("free()d"). Т.о., безопасно установить для
# "memory_pools_limit" приемлимо высокое значение, даже если Ваша конфигурация будет
# использовать меньше памяти.
#
# Если установить "none", то Squid будет хранить столько памяти, сколько сможет. Т.е.
# лимита на общий размер памяти, используемой для безопасного хранения, не будет.
#
# Чтобы выключить оптимизацию выделения памяти, не устанавливайте "memory_pools_limit"
# в "0" или "none". Вместо этого установите "memory_pools" в "off".
#
# Издержки на поддержание пулов памяти, при проверке лимитов не принимаются во внимание.
# Эти издержки, приблизительно, около четырех байтов на объект хранения. Однако, пулы
# действительно могут _СОХРАНИТЬ_ память благодаря уменьшению замусоривания памяти в
# Вашей "malloc"-библиотеке.
#
# Установки по умолчанию:
# memory_pools_limit 5 MB
#
#  TAG: forwarded_for	on|off|transparent|truncate|delete
# Если установлено в "on", Squid будет при форварде добавлять в HTTP-запрос IP-адрес
# Вашего клиента. По умолчанию это выглядит как:
#	X-Forwarded-For: 192.1.2.3
# Если установить в "off", то это будет выглядеть как:
#	X-Forwarded-For: unknown
# Если установить в "transparent", то Squid никак не будет изменять заголовок
# X-Forwarded-For.
# Если установить в "delete", Squid будет удалять X-Forwarded-For-заголовок целиком.
# Если установить в "truncate", Squid удалит все существующие записи X-Forwarded-For, и
# разместит в единственной записи себя (свой адрес).
#
# Установки по умолчанию:
# forwarded_for on
#
#  TAG: cachemgr_passwd
# Указывает пароль для "cachemgr"-операций.
#
# Использование:	cachemgr_passwd password action action ...
#
# Некоторые доступные действия (см. меню "cache manager"-а для получения полного списка):
#	5min
#	60min
#	asndb
#	authenticator
#	cbdata
#	client_list
#	comm_incoming
#	config *
#	counters
#	delay
#	digest_stats
#	dns
#	events
#	filedescriptors
#	fqdncache
#	histograms
#	http_headers
#	info
#	io
#	ipcache
#	mem
#	menu
#	netdb
#	non_peers
#	objects
#	offline_toggle *
#	pconn
#	peer_select
#	reconfigure *
#	redirector
#	refresh
#	server_list
#	shutdown *
#	store_digest
#	storedir
#	utilization
#	via_headers
#	vm_objects
#
#===^===
# * - Указывает действия, которые не будут выполнены без валидного пароля, другие могут
# быть выполнены, если здесь не перечислены.
#* Indicates actions which will not be performed without a valid password, others can be
#performed if not listed here.
#
# Для отключения действия, установите пароль в "disable".
# Для разрешения выполнения действия без пароля, установите пароль в "none".
#To disable an action, set the password to "disable".
#To allow performing an action without a password, set the password to "none".
#=======
#
# Используйте ключевое слово "all" для установки одного пароля для всех действий.
#
# Пример:
#	cachemgr_passwd secret shutdown
#	cachemgr_passwd lesssssssecret info stats/objects
#	cachemgr_passwd disable all
#
# Установки по умолчанию:
# none
#
#  TAG: client_db	on|off
# Если вы хотите отключить сбор статистики о клиентах, то установите здесь "off".
#
# Установки по умолчанию:
# client_db on
#
#  TAG: refresh_all_ims	on|off
# Когда Вы включите эту опцию, Squid будет всегда проверять оригинальный сервер
# на обновления, когда клиент посылает "If-Modified-Since"-запрос. Многие браузеры
# используют IMS-запрос, когда пользователь запрашивает перезагрузку, и эта опция
# гарантирует таким клиентам получение последней версии (обновленного контента).
#
# По умолчанию ("off"), Squid может вернуть "Not Modified"-ответ, основанный на возрасте
# кэшированной версии.
#
# Установки по умолчанию:
# refresh_all_ims off
#
#  TAG: reload_into_ims	on|off
# Когда Вы включите эту опцию, клиентские "no-cache"- или "reload"-запросы будут
# изменяться в "If-Modified-Since"-запросы. Использование этой опции НАРУШАЕТ стандарт
# HTTP. Включение этой функции может сделать Вас ответственным за проблемы, которые она
# вызывает.
#
# Для более избирательного подхода также см. "refresh_pattern".
#
# Установки по умолчанию:
# reload_into_ims off
#
#  TAG: maximum_single_addr_tries
# Тэг устанавливает максимальное количество попыток соединения с хостом, который имеет
# только один IP-адрес (для хоста с несколькими IP-адресами на каждый адрес будет по
# одной попытке).
#
# Значение по умолчанию - одна попытка, максимум (не рекомендуется) - 255 попыток. Если
# установлено значение больше 10, будет генерироватся предупреждающее сообщение.
#
# Примечание: Это дополнение к запросу повторной пересылки (re-forwarding), которая имеет
# место, если Squid не может получить удовлетворяющий ответ.
#
# Установки по умолчанию:
# maximum_single_addr_tries 1
#
#  TAG: retry_on_error
# Если установлено в "on", то при получении "error"-сообщения Squid будет автоматически
# повторять запросы. Это в основном полезно, если Вы работаете над ошибками контроля
# доступа в комплексной кэш-иерархии.
#
# Установки по умолчанию:
# retry_on_error off
#
#  TAG: as_whois_server
# WHOIS-сервер для получения AS-номеров. ПРИМЕЧАНИЕ: AS-номера запрашиваются только
# при запуске Squid, а не для каждого запроса.
# [z_ЛИРИКА: RFC 1930, Автономная система
# http://ru.wikipedia.org/wiki/Автономная_система_(Интернет) ]
#
# Установки по умолчанию:
# as_whois_server whois.ra.net
#
#  TAG: offline_mode
# Включите эту опцию и Squid никогда не будет пытаться проверять кэшированные объекты.
#
# Установки по умолчанию:
# offline_mode off
#
#  TAG: uri_whitespace
# Что делать с запросами, которые имеют пробелы в URI.
#
# Опции:
#	strip:	Пробелы будут вырезаться из URI. Такое поведение рекомендовано RFC2396.
#	deny:	Запрос запрещен. Пользователь получит сообщение "Invalid Request".
#	allow:	Запрос разрешен и URI не меняется. Пробелы остаются в URI. Заметьте, если
#		используется редиректор, то пробелы передаются его процессам.
#	encode:	Запрос разрешен и пробелы кодируются согласно RFC1738. Это может считаться
#		нарушением HTTP/1.1 RFC, потому что прокси-серверам не разрешено
#		перезаписывать URI.
#	chop:	Запрос разрешен и URI будет обрезан после первого пробела. Это так же
#		будет считаться нарушением.
#
# Установки по умолчанию:
# uri_whitespace strip
#
#  TAG: chroot
# Указывает директорию, которую Squid, во время инициализации, должен сделать корневой
# (chroot()). Это так же заставляет Squid полностью утратить привелегии root-а после
# инициализации. Это означает, например, что если Вы используете HTTP-порт с номером ниже
# 1024 и пытаетесь реконфигурировать Squid, Вы можете получить ошибку, сообщающую, что
# Squid не может открыть порт.
#
# Пример:	chroot /squid
#
# Установки по умолчанию:
# none
#
#  TAG: balance_on_multiple_ip
# Современные IP-резолверы в Squid-е сортируют "lookup"-результаты по предпочтительному
# доступу. По умолчанию Squid будет использовать эти IP по порядку, и переходить к
# следующему указанному только тогда, когда более предпочтительный не справится.
#
#===^===
# Некоторые сервера балансировки нагрузки, базирующиеся на DNS-"round robin", как
# обнаружилось, не сохраняют состояние пользовательской сессии при запросах к различным
# IP-адресам.
#Some load balancing servers based on round robin DNS have been found not to preserve
#user session state across requests to different IP addresses.
#=======
#
# С включением этой директивы Squid будет менять IP с каждым запросом.
#
# Установки по умолчанию:
# balance_on_multiple_ip off
#
#  TAG: pipeline_prefetch
#===^===
# Для повышения производительности конвеерных ("pipelined") запросов к ближайшему
# совпадению, которые в непроксированном окружении (среде) Squid может попытаться
# поднять до двух запросов у конвеера параллельно.
#To boost the performance of pipelined requests to closer match that of a non-proxied
#environment Squid can try to fetch up to two requests in parallel from a pipeline.
#
# По умолчанию "off" для управления пропускной способностью и по причинам логирования
# (контроля) доступа.
#Defaults to off for bandwidth management and access logging reasons.
#=======
#
# Установки по умолчанию:
# pipeline_prefetch off
#
#  TAG: high_response_time_warning	(в миллисекундах)
# Если среднее время ответа в течение минуты превышает указанное здесь значение, то Squid
# выведет ПРЕДУПРЕЖДЕНИЕ нулевого "debug"-уровня, для привлечения внимания администратора.
# Значение указывается в миллисекундах.
#
# Установки по умолчанию:
# high_response_time_warning 0
#
#  TAG: high_page_fault_warning
# Если количество ошибок страницы превысит одноминутное среднее значение этого тэга, то
# Squid выведет ПРЕДУПРЕЖДЕНИЕ нулевого "debug"-уровня, для привлечения внимания
# администратора. Значение указывается в "ошибках страницы на секунду".
#
# Установки по умолчанию:
# high_page_fault_warning 0
#
#  TAG: high_memory_warning
# Если использование памяти (как определено "mallinfo") превысит это значение, то
# Squid выведет ПРЕДУПРЕЖДЕНИЕ нулевого "debug"-уровня, для привлечения внимания
# администратора.
#
# Установки по умолчанию:
# high_memory_warning 0 KB
#
#  TAG: sleep_after_fork	(в микросекундах)
# Когда этот тэг установлен в ненулевое значение, основной Squid-процесс будет "засыпать"
# на указанное количество микросекунд после системного вызова "fork()". Этот "сон"
# может помочь в ситуациях, когда Ваша система сообщает об отказе "fork()"-а в результате
# нехватки (виртуальной) памяти. Заметьте, однако, если у Вас много дочерних процессов,
# эти задержки сложатся, и Ваш Squid не будет обслуживать запросы какое-то количество
# времени, до тех пор, пока не стартуют все дочерние процессы. В Винде значения менее
# 1000 (1 миллисекунды) округляются до 1000.
#
# Установки по умолчанию:
# sleep_after_fork 0
#
#  TAG: windows_ipaddrchangemonitor<--->on|off
# В Винде Squid по умолчанию будет мониторить смену IP-адреса, и будет реконфигурировать
# себя после каждого обнаруженного события (смены адреса). Это очень полезно для прокси,
# подключенного к интеренету через диалап-интерфейсы. В некоторых случаях (прокси-сервер
# одновременно является VPN-шлюзом) может быть нежелательным отключать такое поведение
# установкой этог тэга в "off".
# Примечание: После изменения этого тэга Squid-сервис должен быть рестартован.
#
# Установки по умолчанию:
# windows_ipaddrchangemonitor on
#
#  TAG: max_filedescriptors
# Максимальное поддерживаемое число файловых дескрипторов.
#
# По умолчанию "0", подразумевает наследование Squid-ом текущих настроек "ulimit".
#
# Примечание: Изменение этого значения требует перезагрузки Squid. Также не все
# коммуникационные циклы ("comm loops") поддерживают большие значения.
#
# Установки по умолчанию:
# max_filedescriptors 0
