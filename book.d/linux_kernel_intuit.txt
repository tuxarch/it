Внутреннее устройство ядра linux
Курс на ИНТУИТ. Пройден в 2017.
https://www.youtube.com/playlist?list=PLDrmKwRSNx7Ja7NAt21HgNAIlTvJJ4Kso
=============================================




Ядро предоставляет две большие функции:
- управляет ресурсами
- предостовляет интерфейс для пользовательских программ

Взаимодействие с ядром через системный вызов.

Системный вызов - процесс работающий в kernel space 

Ядро располагается вверхним диапозоне памяти

защищенный режим ЦПУ

DMA - способ взаимодействия с устройствами. Выкладываем данные в память и
отдаем команду устройству их считать.

NUMA - разделение памяти между процессами поровну.

SMP - работа на однотипных ЦП
IPI - взаимодействие между процессами на многоядерных системах
APIC - контроллер прерываний от железа

Уровни привелегий на ЦП x86 4 уровня. О самый высокий, 3 низкий

программные прерывания на процессоре

netlink - своего рода сокет для взаимодействия с ядром. 99,9 процентов
сетевой подсистемы написанно на netlink

_____________________

VFS

/proc - взаимодействия с процессами
/sys - работа с kobject. Абстрактные объекты ядра группирующиеся в классы

Чтобы написать драйвер ФС нужно описать объекта 

struct file_system_type myfs{
name
get-mount

точка входа super_block
дерево файлов, указатель на суперблок

inode - индекс на запись
флаги - права доступа, тип, овнер
id
количество жестких ссылок
время линк 
struct directory - флаги, имя

Имя файла все кроме слеша и конца строки


суперблок - экземпляр файловой системы и его начальной точки
В ядре нет сборщика муссора, ядро чистит все самостоятельно

описываем файловую систему, суперблок а затем denty и inode

dentry - cache - кэшируем объекты к общарению к инодам

revalidate - работа с сетевыми фс. Врямя жизни dentry кэша

lru - выбрасывание объектов по времени жизни

buddy - начинает чистить кэш

chroot - изменение корневой системы

dup() - системный вызок копирующий файловый дескриптор
unlinck() - удаление ссылки на файл

дескриптор файла

монтирование

mount() - mount(glib) - sysmount()

файл систем тайп подгружается 

vfsmount - объект указывающий на каталог монтирования
что мы примонтировали, и суперблок.

D_mountpoint - меняет процедуру  lookup

lookup ищет в дочерней папке
D_M - находим, и после этого ищем vsmount и идем дальше искать на другое
устройство

--bind  

vfsmount - поднимает количество ссылок на точку монтирования
результатом lookup пара dentry & vfsmount

struct path 

sys_umount - проверяет vfmsmount количество ссылок

umount -l - отвязать от дерева. До тех пор пока на него ссылается хоть один
объект

Один суперблок может смонтирован много раз.

суперблок имеет параметры только для чтения

монтировать несколько дисков в одну точку нельзя
_________________________

NETWORK STACK

драйвера сетевых устройст объединяются в подсистему netdevices
struck_net_devices
vnic - сетевой адаптер
looback - локальный сетевой интерфейс (сам с собой)
veth - виртуальный адаптер для контейнеров
bonding - объединение сетевых карт в одну логическую

виртуальные устройства

sr_iou - физический адаптер делится на виртуальные

сокет похож на файл за исключением выполнения системного вызова

Приложение работает с сокетом через файловые дескрипторы

ядро выделяет уровни transport, network,mac

Приложение имеет структуру task_struckt c таблицей файлов. Сетевая реализация
также имеет ссылки на denty и inode
есть свой суперблок, vsmount? fstype
sokfs 
сокет создается через системный вызов socket

сокет на иноде
sock структура описывающее текущее состояние соединения

Закрываем приложение, а сетевой стэк живет и завершает работу
Стэк поднялся а приложение к нему не подключилось. Такое возможно при
отсутсвии accept подтверждения.

sock struct - описывает транспортный и сетевой уровень
struct inet_sock - сетевая структура включающая sock struck

struct inet6_sk наследник ip

таблица вертуальных методы - указание на структуру и методы

Передача на сетевой стэк с обертончными данными

Передача выше от сети

skb - отдельный пакет ходящий по системе

outgoing - исходящий трафик

драйвер - зовет функцию со структурой

драйвер имеет структуру net_device в которую он складывает пакеты
softIRQ - отложенные системные прерывания
Прерывания itrx 
Постоянные системные прерывания при сетевом трафике слишком накладны. 
NAPI - одно прерывание на пачку пакетов

функция выделение памяти кmalloc(size,flags) - берет страницу от buddy -
менеджер памяти
структура протокола - ищется соответствующая структура для протокола

Программа поднимает две структуры sock & socket

Транспортный уровень не может просчитать количество необходимой памяти - тк
количество заголовков может увеличиться

Пакет от socketа подает с пришитиыми заголовками на net_device и метод
hard stark smit - функция которая зовет драйвер.

memchashed - kmalloc тоже самое только размеры память с указанной длинной

tcpdump - подключается через сокет pwpacket и неразборчевый режим карты

tcp драйвере проиходит планирование памяти. Управление соединением через окно.

struct sk_buff
-небольшая структура с большой оптимизации

Это объект которые имеет 4 указателя head, end, tail - хвост, data - указатели
на дату. Это линейный skb появившиеся вместе с linux
Проблемы с линейным в том, что плохо масшабируется. 
Появление paged_skb который имеет ссылки на подключаемые страницы.

Операции для чтения и записи заголовков
Пустой skb  data,head,tail - на начале

skb_reserve - резервирует место в хедере сдвигает data,tail вправо
skb_push - сдвигает data

Заполняет поля данными struct data
skb_put - двигает хвост вправо tail

Раставляет указатели при приеме
skb_pull - разбирает заголовки пакета
skb_may_pull - проверка достаточности данных
skb_copy_bits - копирует со страницы в заголовки пакета данные

оптимизация
tail, end - как смещения, а не как указатели. 

sequence - номерация потоков байт
ack - шлет подтвержение полученных номеров пакета

buid_bugon - проверяет размер skbuf - на этапе компиляции.

Пакет пришел с mac-уровня
ip - проверяет пакет и достаточно данных и есть заголовки. Потом пакет идет в
netfilter

Уровень IP это по сути работа с фаерволом и правилам маршрутизации

distination entry добавляет ее routing- указатели на input & output. Вешаем на сокет de для того,
чтобы не гонять пакеты по таблице маршрутизации.
lo- пакет не бегают по маршрутизации

hash-таблица

RCU - создается новый объект с новым указателем. Затем убиваем старый
указатель и объект на который ссылаются другие процессы.

fib - forwarding information base
обработка маршрутизации
_________________________

Планировщик

Сменилось три планировщика linux

scheule() - главная точка входа в планировщик
указатель curent на таск стракт текущего процесс
next - указатель на следующий task_struct

контекс исполнение переключается в случаях:
зовут set_current_state() - который разбудит
по аппаратному таймеру
premitivy kernel - если ядерный код хочет исполнятся то он должен об этом явно 

приоритетность процесс - число 

Старый планировщик - выделялось время работы. Процесс может освободится раньше
чем закончится его время.
cfs - учет времени следит сколько процесс исполнялся и навешивает на него
время исполнения.

smp 
производительность и честность

migration thread - перенесение процесса на другое ядро

контейнерное планирование процессов - планирование по контейнерам
sched_entety - дерево процессов для контейнеров и пользователей

priority inversation 
интерактивный процесс вытесняет другой
__________________________

Page cache - кэш данных зачитанных с диска

режимы
-отсутствие кэша
-write_back - 
-write_thourh - кэш пишутся на носители

режим по умолчанию write_back 
uptodate flag - данные прочитаны
dirty  flag - грязная страничка которая новее данных на носителе

Если место закончилось то можно удалить uptodate старницы
 - кэш пишутся на носители

 режим по умолчаниюю write_back 
 uptodate - данные прочитаны

 dirty - грязная страничка которая новее данных на носителе

 Если место закончилось то можно удалить uptodate старницы
 - кэш пишутся на носители

 режим по умолчаниюю write_back 
 uptodate - данные прочитаны

 dirty - грязная страничка которая новее данных на носителе

 Если место закончилось то можно удалить uptodate старницы

