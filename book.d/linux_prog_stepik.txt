Основы программирования на linux. 2017
https://stepik.org/course/548


build-essential - набор для компиляции ubuntu

vim split:
:sp - сплит окна
:vs - вертикальный сплит
ctrl+w - переключение между сплитами


hello.h
#ifndef __HELLO__
#define __HELLO__
#endif


gcc -o hello.o -c hello.c - собираем объект без линковки

gcc -o hello hello.o main.o - слинковать исполняемый файл

__________________________________________

Выносим функцию в разделяемую библиотеку

функция hello.c

gcc -o libHello.so -shared hello.c  - собираем либу

-fPIC - ключ в случае проблемы сборки, и выравнивания памяти

nm - посмотреть содержимое библиотеки
T - тип текста, те кода

собрать 
gcc main.c -L. -lHello -o hello 

для работы программы:
Закинуть библиотеку в /usr/lib /lib
переменную: export LD_LIBRARY_PATH=./


Манглинг - кодирование имен. Динамическое имя

c++filt _Z13hello_messagePKc - узнать первоначальное имя в библиотеке

extern "C" - добавляем к функции в файле hello.c 
чтобы оставить имя функции

make
утилита управления зависимостями
без параметров запускает первую команду
важны табы в Маkefile

ldd - посмотреть зависимые библиотеки, также для .so


libdl 

hdl = dlopen (libHello.so)
dlsym(hdl)

__________________________________________

Файловые системы

файл - есть системный интерфейс

Опираться в своей деятельности на системные вызовы

читаем ман
man 2 - информация по системным вызовам

O_RDONLY,O_WRONLY, O_RDWR

filelock - блориовка доступу к файлом
fnctl - управление файловым дескриптором

creat - cоздание и удаление файла

Катог - файл описывающий входящий в него файлы и каталоги

dir <dirent.h> - своеобразный итератор структуры данных

readdir - читать каталог

Ссылки

stat - информация по файлу

ln  file file.hardlink
ln -s file file.softlink

софтовая ссылка - это файл со своей инодой ссылающийся на файл

O_NOFFOLOF - не открывать ссылки
O_PATH - открыть саму файловую ссылку

__________________________________________

/procfs

ltrace - показывает какие библиотеки
strace - системные вызовы

Пользователь обращается к write к ядру sys_write -> обращение к драйверу ФС

/proc/ID/cwd - текущая директория

____________________________________
gdb - отладчик
ulimit -c unlimited


gcc -g 3 - большое количество отладки
gcc -o 0 - уровень оптимизации отключить

gdb ./exec
gdb ./exec -c core_file_dump.txt 
gdb ./exe -pid pid - подключиться к уже работающей программе

информация о состояниях всего
брекпоинты и пошаговое выполнение
смотреть стэк

help command
info
	args
	breakpoins
	watchpoits
	registers
	threads
	signals
where - backtrace - стэк исполняемого файла

gdb attach pid - подключиться к уже запущенному процессу

Cреда разработки работает gdb

echo $$ - ид-текущей консоли

fork/exec 
fork - точная копия текущего процесса
exec - замещение образа процесса

wait - дождаться завершения процесса

Зомби - процесс который завершился, но ждет когда родительский процесс считает код
завершения.

fork 
_____
Сетевая служба 
inet 
gethosbyname <netdb.h> - библиотека c

серверный сокет
__________________________________________

Планировщик

по умолчанию 32768 - процессов
До 4млн - <linux/threads.h>

состояние процесса 
_TASK_RUNNING
_TASK_INTERRUPTIBLE - в ожидании события
_TASK_UNINTERUPTEBLE - в ожидании, но сразу в run не переводится
_TASK_TRACE - троссировк
_TASK_STOP - в остановленном виде


процесс после форка получает ts и при завершении получает состояние
task_zombie которое должно отдать код завершение.

set task state (task,state) - меняем стандартные механизмы планирования

Менеджер памяти
память выделяется постранично 
gdt - глобальная страница
ldt - локальная таблица дескрипторов

memory managment unit - аппаратное управление страниц. Страницы могут
сбрасываться на диск

void * kmalloc (size, flag) - выделение памяти

куча флагов для выделение памяти, указываем откуда выделять

user space/kernel space 

read -> glibc -> system_call -> sys_read
от приложения к библиотеке, функция перехода в ядро и обработка вызова

ebx, ecx, edx, esi - регистры которые не требуют привелегий
указатель на адресс с данными

создание процесса 
меняется task struct - меняется pid ppid
exec - замена памяти старого процесса
реальное создание пространства процесса происходит при записи

dub_task_struct
проверка лимита на кол-во процессов
модификация pid ppid
состояние процесса t_uninterraptable
установка флагов процесс
alloc_pid
проверяется clone

проверяется id, выполняется exec который запускает функцию main

структура данных в ядре
списки двунаправленные - два указателя на предыдущий и последующий
<linux/list.h>

________________________________________________
Прерывания и исключения

исключения - синхронные
прерывания асинхронные и могут прилететь

маскируемы и нет прерывания. eflags - позволяет не обрабатывать маскируемые
прерывания

apic - контроллер прерываний
/proc/interrups - список прерываний

<linux/interrupt.h> 
<asm/irg.h> - отключить или разрешить прерывания

ioctl - управление устройствами ввода.вывода

специальные прерывания для специфический функций. Пример открытие cd-rom

<sys/ioctl.h> 
устройство монтируется в режиме ядра в виде файла. Пользовательский интерфейс
работает с этим файлом.

jiffys - таймер 

синхронизация процессов
 - атомарные операции (битовые)
 - спинлоки
 - семафоры
 - функции завершения
 - счетчики ссылок
