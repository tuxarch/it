Язык является объектно-оринтированным. Программные модули являются объектами
т.е имеют свойства и методы.



import - подключения модуля

from - import  - подключения функции из модуля





     Вместо операторных скобок используется отступы и пробелы

     Числа могут быть:

                    int - целыми

                    float - вещественными. Вещественные числа неточны и не
поддерживают длинную арифметику.

                    long - длинными целыми

                    также комплексными.

Для преобразования служат команды приведения типов int(), long(), float().
Числа могут быть сколь угодно длинными, за исключением символов после точек,
их может быть не больше 10 (0.0000000000)



Арифметические действия стандартны стоит упомянуть:

               x/y - целочисленное деление, если не один из элементов не
является вещественным (float)

               x//y - результатом будет всегда целое число

               х**y - возведение в степень y

               x%y - остаток от деления, может быть и целочисленным и float



               abs (x) - возвращает нам модуль числа

               divmod(x,y) - целочисленное деление, результ частное и остаток.
Результа представляет картеж.

               pow(число, степень) - возведение в степень

               round() - округление числа



Логические опереции стандартны

               != неравенство

               x and y - логическое И

               x or y - логическое ИЛИ

               x in y - принадлежность x к y

               not x - условие отрицания



Последовательности

          Неизменяемые последовательности

                         -Строки. одиночный символ строки имеет формат строки. максимальное значение строки сколь угодно большое

                    Для приведения числа к строке необходимо использовать
метод str(), также возможно и обратное действие.

          ord() - позволяет узнать АСКИ-код символа

          chr() - вывести символ по АСКИ-коду

     Операции над строками:

          len() - выводит длинну строки

          n*2 - повторение строки 2 раза

          [j:I:k] - срез, выводит символы от значения j до k (не включая его),
с шагом k.

          min(), max() - коды с наибольшим, наименьшим значением в таблице.

Методы строк:

       .center(n) - добавляет символы справа и слева до длины строки в n
символов.

           .ljust(n) - выравнивает строки по левому краю

          .rjust(n)

          count() - позволяет находить повторение строки в строке, также может
быть расширена с помощью [начального элемента, шага]

          find() - определяется позиция вхождения последовательности в строку.
Т.е выдает нам индекс того символа, где встречается последовательность.

          rfind

          strip, lstrip, rstrip - удаляет пробелы в начале строки, или в конце
в соответствии с командой.

          replace(x,n) - меняет х в строке на n , также может быть указано
количество замен.

          capitalize, swapcase, upper, lower - позволяют менять регистр в
строке.

     Кортежи, также являются неизменяемыми последовательностями

     Элементам кортежа можно присвоить имена. так же чтобы не обращаться к
переменным картежа или массива через индексы можно назначить имена переменных
для элементов массива.

 Картежи являются неизменными послеовательностями по своему значению и по
длинне.

Содержит похожие методы, что и строки: е[i;i;i], max, min, n*n, len,

tuple() - позволяет преобразовать в данный тип ТОЛЬКО СТРОКИ.

Списки ** . **  Позволяют также проинициализировать переменные с помощью своих
элементов.

               del() - также можно применять с различными комбинациями среза.

               append() - добавляет элемент в конец списка

               extend() - добавляет картеж или список в конец списка

               count() - позволяет находить количество повторяющихся
элементов.

               .index() - выводит индекс по заданному значению

               .remove() - позволет удалять элемент исходя из его значения

               ,pop() - удаляет элемент по индексу, если индекс не указан
удаляется последний элемент.

               insert(x,y) - вставляет элемент y в индекс x, тем самым
расширяя массив.

               sort() reverse() - сортировка массива по возрастанию

Методы zip() и map() позволяют объединять списки и кортежи по элементам.

lambda - функция безымянная, действующая для конкретной операции.

k.map(lambda x,y: x+y,sr,st) - позволяет складывать два списка причем функция
lambda x,y: x+y

sum() = позволяет высчитывать сумму списка

list() - позволяет приводить картеж или строку в список. Так же возможно и
обратное приведение.

split() - создает список из строки с указанием разделителя

"sf".join(lst) - создает строку из списка, правда есть проблемма с поддержкой
символов в списке



range(i,i,i) - создает список как числовую прогрессию, по типу среза.
Существуют три варианта записи одно значение указывает на максимально
возможное значение элементов списка. Часто вместе с этой функцией используется
принадлежность (in).



** Ввод данных **

реализуется с помощью raw_input, input = причем можно вводить
последовательность переменных таким образом. Но СПИСОК таким образом ввести не
получается, таким образом вводится картеж, который затем приводится в lst.
Отличие input raw_input заключается в том, что ненадо вводить кавычки в
последнем случае.

Функция print автоматически устанавливает пробелы между элементами.

Для работы с файлами, в частности если необходимо достать числа, можно
применить функцию split.

readline() - позволяет считать строку, при повторном использовании считывает
последующую.

readlines() - читает строки и формирует из них список





